<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 기획전 대시보드</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.26/dist/interact.min.js"></script>
    <!-- config.js 에서 API 키 로드 (서버 없이 쓸 때). 없으면 getGeminiApiKey 등은 빈 문자열 반환 -->
    <script src="config.js"></script>
    <style>
        /* 하단 시안 영역으로 부드럽게 넘어가기 위한 설정 */
        html { scroll-behavior: smooth; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        /* main이 헤더·인사이트 아래 남은 높이를 꽉 채우도록 */
        html, body { height: 100%; }
        .main-content {
            flex: 1 1 0%;
            min-height: 0;
            display: grid;
            grid-template-columns: repeat(12, minmax(0, 1fr));
            grid-template-rows: 1fr;
        }
        .overlay-text-box { position: absolute; cursor: move; user-select: none; white-space: nowrap; }
        .overlay-text-box.dragging { outline: 1px dashed rgba(255,255,255,0.9); outline-offset: 2px; }
        .overlay-text-box .resize-handle { position: absolute; right: -2px; bottom: -2px; width: 12px; height: 12px; cursor: nwse-resize; background: rgba(255,255,255,0.6); border-radius: 2px; }
        .overlay-text-box .resize-handle:hover { background: rgba(255,255,255,0.9); }
        .overlay-text-box[data-target^="mo-"] { white-space: normal; max-width: 88%; word-break: keep-all; line-height: 1.2; }
        .image-loading-overlay { display: none; position: fixed; inset: 0; background: rgba(255,255,255,0.9); z-index: 9999; align-items: center; justify-content: center; flex-direction: column; gap: 1rem; }
        .image-loading-overlay.visible { display: flex; }
        .image-loading-overlay .spinner { width: 48px; height: 48px; border: 4px solid #e5e7eb; border-top-color: #4f46e5; border-radius: 50%; animation: spin 0.9s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 overflow-y-auto overflow-x-hidden min-h-screen">

    <!-- 이미지 생성 중 전역 로딩 오버레이 -->
    <div id="imageLoadingOverlay" class="image-loading-overlay" aria-hidden="true">
        <div class="spinner" role="presentation"></div>
        <p id="imageLoadingOverlayMessage" class="text-lg font-semibold text-indigo-600">AI 디자이너가 고화질 시안을 그리고 있습니다...</p>
    </div>

    <div id="dashboard" class="flex flex-col h-screen flex-shrink-0 overflow-hidden">
        <header class="w-full bg-white border-b z-10 shrink-0">
            <div class="p-4 border-b">
                <h1 class="text-3xl font-bold text-indigo-600">Instant Campaign</h1>
            </div>
            <div class="px-4 py-4 flex gap-4 items-center bg-gray-50">
                <span class="font-medium text-gray-600">브랜드 선택:</span>
                <label class="flex items-center gap-1 cursor-pointer">
                    <input type="radio" name="brand" value="DV" class="w-4 h-4 text-indigo-600" checked>
                    <span class="font-semibold">DV</span>
                </label>
                <label class="flex items-center gap-1 cursor-pointer">
                    <input type="radio" name="brand" value="ST" class="w-4 h-4 text-indigo-600">
                    <span class="font-semibold">ST</span>
                </label>
            </div>
        </header>

        <div id="aiInsightBar" class="w-full bg-indigo-50 border-b border-indigo-100 shrink-0 px-4 py-3 flex gap-3 items-start">
            <span class="text-sm font-semibold text-indigo-700 whitespace-nowrap pt-0.5">🤖 AI MD 제안</span>
            <div id="aiInsightText" class="text-sm text-gray-700 min-w-0 flex-1 leading-relaxed whitespace-pre-wrap">트렌드 키워드를 불러오는 중입니다. 로드 후 자동으로 제안이 표시됩니다.</div>
        </div>

        <main class="main-content grid grid-cols-12 grid-rows-[1fr] gap-0 flex-1 min-h-0 overflow-hidden w-full">
        
        <section class="col-span-3 border-r bg-white p-4 min-h-0 overflow-y-auto">
            <h2 class="text-base font-bold mb-3 text-gray-700">1. 검색어 선택</h2>
            <div class="flex items-center justify-between mb-2">
                <span id="trendsUpdateTime" class="text-sm font-bold text-gray-400 uppercase">트렌드 (로딩 중...)</span>
                <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                </svg>
            </div>
            <div class="mb-2 text-right">
                <span class="text-xs font-medium text-gray-600">검색량</span>
            </div>
            <div id="trendsList" class="space-y-1">
                <!-- 동적으로 로드될 트렌드 리스트 -->
            </div>
            <button type="button" id="trendsReloadBtn" class="mt-3 w-full py-2 text-sm font-medium text-indigo-600 border border-indigo-200 rounded-lg hover:bg-indigo-50">다시 불러오기</button>
        </section>

        <section class="col-span-4 border-r p-4 min-h-0 overflow-y-auto bg-white">
            <h2 class="text-base font-bold mb-3 text-gray-700">2. 상세 설정</h2>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">제품 이미지(누끼컷) — 배경 합성용</label>
                    <div id="referenceImageZone" class="w-full h-24 border-2 border-dashed rounded-lg flex flex-col items-center justify-center text-gray-400 hover:bg-gray-50 cursor-pointer transition-colors">
                        <input type="file" id="referenceImageInput" accept="image/*" class="hidden">
                        <svg class="w-6 h-6 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M12 4v16m8-8H4"></path></svg>
                        <span id="referenceImageLabel" class="text-xs">제품 이미지를 올리면 키워드와 기획의도에 맞는 배경에 합성합니다</span>
                    </div>
                    <p class="text-xs text-gray-500 mt-1.5">또는 아래에 <strong>이미지 URL</strong>을 넣어도 됩니다 (FAL·Replicate 모두 URL 지원)</p>
                    <input type="url" id="referenceImageUrlInput" placeholder="https:// 예시 이미지 주소" class="mt-1.5 w-full border border-gray-300 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-indigo-500 outline-none">
                </div>
                <div id="aiModeSection">
                    <label class="block text-sm font-medium text-gray-700 mb-2">AI 생성 모드</label>
                    <div class="space-y-2">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="aiGenerateMode" value="product" class="w-4 h-4 text-indigo-600">
                            <span class="text-sm text-gray-600"><span class="font-medium text-indigo-700">제품 중심(연출컷)</span> — 제품이 주인공인 연출 사진</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="aiGenerateMode" value="person" class="w-4 h-4 text-indigo-600">
                            <span class="text-sm text-gray-600"><span class="font-medium text-indigo-700">인물 중심(모델컷)</span> — 인물/모델이 주인공인 연출 사진</span>
                        </label>
                    </div>
                    <p id="aiModeHint" class="mt-1.5 text-xs text-gray-400">생성 모드는 선택사항입니다.</p>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">이미지 생성 API</label>
                    <div class="space-y-2">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="imageApi" value="fal" checked class="w-4 h-4 text-indigo-600">
                            <span class="text-sm text-gray-600"><span class="font-medium text-indigo-700">FAL API</span> — 빠른 생성, 기본 배경 교체</span>
                        </label>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="imageApi" value="replicate" class="w-4 h-4 text-indigo-600">
                            <span class="text-sm text-gray-600"><span class="font-medium text-indigo-700">Replicate API</span> — 서버 프록시 필요 (server.js 실행 필요)</span>
                        </label>
                    </div>
                    <p class="text-xs text-amber-700 mt-1 bg-amber-50 border border-amber-200 rounded px-2 py-1">⚠️ <strong>한도 초과(429)가 자주 나오는 이유:</strong> 결제 수단 없이 쓰면 <strong>분당 최대 6회</strong>만 허용됩니다. 시안 1회 = MO+PC 2회라서 1분에 2~3번만 생성 가능. 결제 추가 시 분당 600회로 완화됩니다. 429 나오면 35초 후 자동 재시도(1회)합니다.</p>
                    <div id="serverStatus" class="text-xs mt-2 hidden">
                        <span id="serverStatusText" class="text-gray-500"></span>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">Replicate API 사용 시: <code class="bg-gray-100 px-1 rounded">node server.js</code> 실행 후 사용하세요.</p>
                    <p class="text-xs text-amber-700 mt-1.5 bg-amber-50 border border-amber-200 rounded px-2 py-1.5">
                        💡 <strong>무료로 테스트하려면:</strong> <span class="font-medium text-indigo-700">FAL API</span>를 선택하세요. fal.ai 가입 후 크레딧으로 체험 가능. Replicate는 결제 수단 없이도 ‘Try for Free’로 제한적 체험 가능(분당 요청 수 제한 있음).
                    </p>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">기획 의도 및 강조점</label>
                    <textarea id="campaignIntent" class="w-full border rounded-lg p-3 h-24 text-sm focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="예: 신규 회원 가입 혜택을 가장 크게 보여줘."></textarea>
                    <p class="mt-1.5 text-xs text-gray-500">
                        💡 <strong>효과적인 작성 팁:</strong><br>
                        • 구체적인 배경/장소: "대학 캠퍼스", "모던 오피스", "자연스러운 실내"<br>
                        • 분위기/감성: "프리미엄 느낌", "청량한 느낌", "따뜻한 분위기"<br>
                        • 강조하고 싶은 요소: "제품이 돋보이게", "브랜드 고급스러움 강조"<br>
                        • 스타일: "미니멀", "럭셔리", "트렌디", "클래식"
                    </p>
                </div>
            </div>
        </section>

        <section class="col-span-5 p-4 min-h-0 overflow-y-auto bg-gray-50">
            <h2 class="text-base font-bold mb-3 text-gray-700">3. 기획전 템플릿 <span class="text-xs font-normal text-gray-500">(선택사항)</span></h2>
            <div class="grid grid-cols-2 gap-3">
                <div class="template-card relative bg-gray-100 rounded-lg p-4 cursor-pointer border-2 border-transparent transition-all duration-200 hover:scale-[1.02] hover:shadow-md ring-4 ring-indigo-500 ring-offset-2" data-template="A">
                    <div class="absolute top-2 right-2 w-6 h-6 rounded-full bg-indigo-500 flex items-center justify-center text-white template-check">
                        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/></svg>
                    </div>
                    <p class="text-sm font-bold text-gray-800 mb-1">템플릿 A</p>
                    <p class="text-xs text-gray-500 mb-2">배너형 · 키워드 강조</p>
                    <div class="aspect-video max-h-24 rounded bg-white border border-gray-200 overflow-hidden flex items-center justify-center mb-2">
                        <svg class="w-full h-full p-1 text-indigo-200" viewBox="0 0 120 60" preserveAspectRatio="none"><rect width="120" height="60" fill="none" stroke="currentColor" stroke-width="1"/><line x1="0" y1="20" x2="120" y2="20" stroke="currentColor" stroke-width="1"/><line x1="0" y1="40" x2="80" y2="40" stroke="currentColor" stroke-width="1"/></svg>
                    </div>
                    <div class="flex gap-1.5 p-1.5 bg-white rounded border border-gray-200 w-fit" onclick="event.stopPropagation()">
                        <button type="button" class="template-variant px-2.5 py-1 text-xs rounded bg-indigo-600 text-white font-medium" data-template="A" data-variant="PC">PC</button>
                        <button type="button" class="template-variant px-2.5 py-1 text-xs rounded text-gray-500 hover:bg-gray-100" data-template="A" data-variant="MO">MO</button>
                    </div>
                </div>
                <div class="template-card template-card--preparing relative bg-gray-100 rounded-lg p-4 border-2 border-transparent transition-all duration-200 opacity-75 cursor-not-allowed pointer-events-none" data-template="B">
                    <div class="absolute inset-0 rounded-lg bg-gray-200/80 flex items-center justify-center z-10 pointer-events-auto">
                        <span class="text-sm font-bold text-gray-600">준비중</span>
                    </div>
                    <div class="absolute top-2 right-2 w-6 h-6 rounded-full bg-indigo-500 flex items-center justify-center text-white hidden template-check">
                        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/></svg>
                    </div>
                    <p class="text-sm font-bold text-gray-800 mb-1">템플릿 B</p>
                    <p class="text-xs text-gray-500 mb-2">카드형 · 세일즈 강조</p>
                    <div class="aspect-video max-h-24 rounded bg-white border border-gray-200 overflow-hidden flex items-center justify-center mb-2">
                        <svg class="w-full h-full p-1 text-indigo-200" viewBox="0 0 120 60" preserveAspectRatio="none"><rect width="120" height="60" fill="none" stroke="currentColor" stroke-width="1"/><rect x="5" y="5" width="35" height="25" fill="none" stroke="currentColor" stroke-width="1"/><rect x="45" y="5" width="35" height="25" fill="none" stroke="currentColor" stroke-width="1"/><rect x="85" y="5" width="30" height="25" fill="none" stroke="currentColor" stroke-width="1"/><rect x="5" y="35" width="55" height="20" fill="none" stroke="currentColor" stroke-width="1"/><rect x="65" y="35" width="50" height="20" fill="none" stroke="currentColor" stroke-width="1"/></svg>
                    </div>
                    <div class="flex gap-1.5 p-1.5 bg-white rounded border border-gray-200 w-fit" onclick="event.stopPropagation()">
                        <button type="button" class="template-variant px-2.5 py-1 text-xs rounded text-gray-500 hover:bg-gray-100" data-template="B" data-variant="PC">PC</button>
                        <button type="button" class="template-variant px-2.5 py-1 text-xs rounded text-gray-500 hover:bg-gray-100" data-template="B" data-variant="MO">MO</button>
                    </div>
                </div>
                <div class="template-card template-card--preparing relative bg-gray-100 rounded-lg p-4 border-2 border-transparent transition-all duration-200 opacity-75 cursor-not-allowed pointer-events-none" data-template="C">
                    <div class="absolute inset-0 rounded-lg bg-gray-200/80 flex items-center justify-center z-10 pointer-events-auto">
                        <span class="text-sm font-bold text-gray-600">준비중</span>
                    </div>
                    <div class="absolute top-2 right-2 w-6 h-6 rounded-full bg-indigo-500 flex items-center justify-center text-white hidden template-check">
                        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/></svg>
                    </div>
                    <p class="text-sm font-bold text-gray-800 mb-1">템플릿 C</p>
                    <p class="text-xs text-gray-500 mb-2">리스트형 · 브랜드 스토리</p>
                    <div class="aspect-video max-h-24 rounded bg-white border border-gray-200 overflow-hidden flex items-center justify-center mb-2">
                        <svg class="w-full h-full p-1 text-indigo-200" viewBox="0 0 120 60" preserveAspectRatio="none"><rect width="120" height="60" fill="none" stroke="currentColor" stroke-width="1"/><line x1="10" y1="12" x2="110" y2="12" stroke="currentColor" stroke-width="1"/><line x1="10" y1="24" x2="110" y2="24" stroke="currentColor" stroke-width="1"/><line x1="10" y1="36" x2="90" y2="36" stroke="currentColor" stroke-width="1"/><line x1="10" y1="48" x2="100" y2="48" stroke="currentColor" stroke-width="1"/></svg>
                    </div>
                    <div class="flex gap-1.5 p-1.5 bg-white rounded border border-gray-200 w-fit" onclick="event.stopPropagation()">
                        <button type="button" class="template-variant px-2.5 py-1 text-xs rounded text-gray-500 hover:bg-gray-100" data-template="C" data-variant="PC">PC</button>
                        <button type="button" class="template-variant px-2.5 py-1 text-xs rounded text-gray-500 hover:bg-gray-100" data-template="C" data-variant="MO">MO</button>
                    </div>
                </div>
                <div class="template-card template-card--preparing relative bg-gray-100 rounded-lg p-4 border-2 border-transparent transition-all duration-200 opacity-75 cursor-not-allowed pointer-events-none" data-template="D">
                    <div class="absolute inset-0 rounded-lg bg-gray-200/80 flex items-center justify-center z-10 pointer-events-auto">
                        <span class="text-sm font-bold text-gray-600">준비중</span>
                    </div>
                    <div class="absolute top-2 right-2 w-6 h-6 rounded-full bg-indigo-500 flex items-center justify-center text-white hidden template-check">
                        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/></svg>
                    </div>
                    <p class="text-sm font-bold text-gray-800 mb-1">템플릿 D</p>
                    <p class="text-xs text-gray-500 mb-2">이벤트형 · 프로모션 강조</p>
                    <div class="aspect-video max-h-24 rounded bg-white border border-gray-200 overflow-hidden flex items-center justify-center mb-2">
                        <svg class="w-full h-full p-1 text-indigo-200" viewBox="0 0 120 60" preserveAspectRatio="none"><rect width="120" height="60" fill="none" stroke="currentColor" stroke-width="1"/><rect x="10" y="10" width="100" height="15" fill="none" stroke="currentColor" stroke-width="1"/><rect x="10" y="30" width="45" height="20" fill="none" stroke="currentColor" stroke-width="1"/><rect x="65" y="30" width="45" height="20" fill="none" stroke="currentColor" stroke-width="1"/></svg>
                    </div>
                    <div class="flex gap-1.5 p-1.5 bg-white rounded border border-gray-200 w-fit" onclick="event.stopPropagation()">
                        <button type="button" class="template-variant px-2.5 py-1 text-xs rounded text-gray-500 hover:bg-gray-100" data-template="D" data-variant="PC">PC</button>
                        <button type="button" class="template-variant px-2.5 py-1 text-xs rounded text-gray-500 hover:bg-gray-100" data-template="D" data-variant="MO">MO</button>
                    </div>
                </div>
            </div>
            <p id="generateStatus" class="mt-4 text-sm text-indigo-600 min-h-[1.5rem] py-1"></p>
            <div class="mt-4 flex gap-2">
                <button id="generateButton" class="flex-1 bg-indigo-600 text-white py-4 rounded-xl font-bold text-lg hover:bg-indigo-700 transition-all shadow-lg">
                    AI 시안 생성하기 ↓
                </button>
                <button id="resetButton" class="flex-1 bg-gray-500 text-white py-4 rounded-xl font-bold text-lg hover:bg-gray-600 transition-all shadow-lg">
                    초기화
                </button>
            </div>
        </section>
    </main>
    </div>

    <div id="result" class="min-h-screen w-full bg-indigo-50/60 border-t-2 border-indigo-200 p-4 md:p-6 scroll-mt-4">
        <div class="grid grid-cols-12 gap-0 w-full max-w-full">
            <div class="col-span-12 mb-4">
                <h2 class="text-2xl font-bold text-gray-800 border-b border-indigo-300 pb-3">AI 생성 기획전 시안</h2>
            </div>

            <!-- 좌+중앙: 시안 갤러리 (col-span-8) — 비율 유지, 텍스트 편집과 간격 확보 -->
            <div class="col-span-12 lg:col-span-8 flex flex-col min-h-0 pr-0 lg:pr-6">
                <div class="flex flex-row items-center justify-start gap-4 h-[440px] min-h-[440px] max-w-full rounded-xl border border-indigo-200/80 bg-white shadow-sm overflow-x-auto overflow-y-hidden p-4">
                    <div id="resultMoCapture" class="relative overflow-hidden rounded-lg flex-shrink-0 h-full w-auto min-w-[180px]" style="aspect-ratio: 2304/3500;">
                        <img id="resultMoImage" src="" alt="MO 시안" class="absolute inset-0 w-full h-full object-contain object-center hidden">
                        <p id="resultMoPlaceholder" class="absolute inset-0 flex items-center justify-center text-gray-500 py-12 px-6 text-center text-sm bg-gray-100">키워드 선택 후 AI 시안 생성하기를 누르세요.</p>
                        <div id="resultMoOverlay" class="absolute inset-0 bg-gradient-to-b from-black/30 to-transparent hidden" style="pointer-events:none">
                            <div class="overlay-text-box" data-target="mo-brand" style="pointer-events:auto; left:0; top:0;"><span id="resultMoBrand" class="font-bold text-white/95 tracking-wide">DV 26SS 컬렉션</span><span class="resize-handle" title="크기 조절"></span></div>
                            <div class="overlay-text-box" data-target="mo-keyword" style="pointer-events:auto; left:0; top:0;"><span id="resultMoKeyword" class="font-black text-white tracking-tight uppercase leading-tight break-words">키워드</span><span class="resize-handle" title="크기 조절"></span></div>
                        </div>
                    </div>
                    <div id="resultPcCapture" class="relative overflow-hidden rounded-lg flex-shrink-0 h-full w-auto" style="aspect-ratio: 3840/1760;">
                        <img id="resultPcImage" src="" alt="PC 시안" class="absolute inset-0 w-full h-full object-cover object-center hidden">
                        <p id="resultPcPlaceholder" class="absolute inset-0 flex items-center justify-center text-gray-500 py-12 px-6 text-center text-sm bg-gray-100">키워드 선택 후 AI 시안 생성하기를 누르세요.</p>
                        <div id="resultPcOverlay" class="absolute inset-0 bg-gradient-to-b from-black/30 to-transparent hidden" style="pointer-events:none">
                            <div class="overlay-text-box" data-target="pc-brand" style="pointer-events:auto; left:0; top:0;"><span id="resultPcBrand" class="font-bold text-white/95 tracking-wide">DV 26SS 컬렉션</span><span class="resize-handle" title="크기 조절"></span></div>
                            <div class="overlay-text-box" data-target="pc-keyword" style="pointer-events:auto; left:0; top:0;"><span id="resultPcKeyword" class="font-black text-white tracking-tight uppercase leading-tight break-words">키워드</span><span class="resize-handle" title="크기 조절"></span></div>
                        </div>
                    </div>
                </div>
                <div class="flex flex-row flex-wrap gap-2 mt-2">
                    <button type="button" id="copySvgMoBtn" class="px-3 py-2 rounded-lg border border-indigo-300 bg-indigo-50 text-indigo-700 text-sm font-medium hover:bg-indigo-100 transition-colors">피그마용 SVG 복사 (MO)</button>
                    <button type="button" id="copySvgPcBtn" class="px-3 py-2 rounded-lg border border-indigo-300 bg-indigo-50 text-indigo-700 text-sm font-medium hover:bg-indigo-100 transition-colors">피그마용 SVG 복사 (PC)</button>
                </div>
            </div>

            <!-- 우측: 컨트롤 패널 (col-span-4) — 상단 3번(col-span-4)과 가로 동일 -->
            <div class="col-span-12 lg:col-span-4 p-4 min-h-0 overflow-y-auto bg-white border-l border-gray-200 flex flex-col gap-6">
                <h3 class="text-base font-bold text-gray-700">텍스트 편집</h3>
                <div class="rounded-lg bg-amber-50 border border-amber-200/80 px-3 py-2 mb-3">
                    <p class="text-xs text-amber-800 font-medium">문구가 시안에서 잘 보이려면 짧게 쓰세요.</p>
                    <p class="text-xs text-amber-700 mt-0.5">상단 문구 10자 내외, 메인 문구 15자 내외(영문이면 3~4단어) 권장.</p>
                </div>
                <div class="space-y-3">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">상단 문구</label>
                        <input type="text" id="editBrand" class="w-full px-3 py-2 rounded-lg border border-gray-300 text-gray-800 text-sm placeholder-gray-400 focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="예: DV 26SS 컬렉션" maxlength="20">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">메인 문구</label>
                        <input type="text" id="editKeyword" class="w-full px-3 py-2 rounded-lg border border-gray-300 text-gray-800 text-sm placeholder-gray-400 focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="예: SPRING IN QUIET LIGHT" maxlength="25">
                    </div>
                    <div class="space-y-2">
                        <p class="text-sm font-medium text-gray-700">문구 크기 (px)</p>
                        <div class="grid grid-cols-2 gap-2">
                            <div>
                                <label class="block text-xs text-gray-500 mb-0.5">MO 상단</label>
                                <input type="number" id="editMoBrandSize" class="w-full px-3 py-2 rounded-lg border border-gray-300 text-gray-800 text-sm" min="8" max="72" value="14" placeholder="8~72">
                            </div>
                            <div>
                                <label class="block text-xs text-gray-500 mb-0.5">MO 메인</label>
                                <input type="number" id="editMoKeywordSize" class="w-full px-3 py-2 rounded-lg border border-gray-300 text-gray-800 text-sm" min="8" max="72" value="28" placeholder="8~72">
                            </div>
                            <div>
                                <label class="block text-xs text-gray-500 mb-0.5">PC 상단</label>
                                <input type="number" id="editPcBrandSize" class="w-full px-3 py-2 rounded-lg border border-gray-300 text-gray-800 text-sm" min="8" max="72" value="16" placeholder="8~72">
                            </div>
                            <div>
                                <label class="block text-xs text-gray-500 mb-0.5">PC 메인</label>
                                <input type="number" id="editPcKeywordSize" class="w-full px-3 py-2 rounded-lg border border-gray-300 text-gray-800 text-sm" min="8" max="72" value="36" placeholder="8~72">
                            </div>
                        </div>
                    </div>
                </div>
                <div>
                    <h3 class="text-base font-bold text-gray-700 mb-2">디렉션 & 재생성</h3>
                    <textarea id="resultFeedback" rows="4" class="w-full px-3 py-2 rounded-lg border border-gray-300 text-gray-800 text-sm placeholder-gray-400 focus:ring-2 focus:ring-indigo-500 outline-none resize-y min-h-[100px]" placeholder="자연어 피드백 입력 (예: 배경을 더 밝게, 톤 다운 등)"></textarea>
                    <div class="mt-2 flex flex-wrap gap-2 justify-end">
                        <button type="button" id="developImageBtn" class="px-4 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-medium border border-indigo-600">이미지 디벨롭</button>
                        <button type="button" id="regenerateImageBtn" class="px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-800 text-white text-sm font-medium border border-gray-700">이미지 재생성</button>
                    </div>
                </div>
                <div class="mt-auto pt-4 border-t border-gray-200">
                    <h3 class="text-base font-bold text-gray-700 mb-2">다운로드</h3>
                    <div class="flex flex-col gap-2">
                        <button type="button" id="downloadMoBtn" class="w-full py-2.5 text-sm font-medium text-indigo-600 border border-indigo-200 rounded-lg hover:bg-indigo-50 transition-colors">MO 시안 저장 (PNG)</button>
                        <button type="button" id="downloadPcBtn" class="w-full py-2.5 text-sm font-medium text-indigo-600 border border-indigo-200 rounded-lg hover:bg-indigo-50 transition-colors">PC 시안 저장 (PNG)</button>
                        <button type="button" id="downloadAllBtn" class="w-full py-3 text-sm font-bold text-white bg-indigo-600 hover:bg-indigo-700 border border-indigo-600 rounded-lg transition-colors">모든 시안 압축 다운로드</button>
                    </div>
                </div>
            </div>
        </div>

        <button onclick="window.scrollTo(0,0);" class="mt-8 text-indigo-600 underline hover:text-indigo-800 text-sm font-medium">다시 설정하러 가기</button>
    </div>

    <script>
        // ========== 서버 없이 쓸 때: config.js 키로 브라우저에서 직접 호출. 서버 쓸 때: API_BASE 설정하면 /api/* 로 요청 ==========
        var API_BASE = ''; // 서버 배포 시 여기 백엔드 URL 넣으면 Gemini/FAL/Replicate 모두 서버 경유
        if (typeof getGeminiApiKey === 'undefined') { function getGeminiApiKey() { return ''; } }
        if (typeof getFalApiKey === 'undefined') { function getFalApiKey() { return ''; } }
        if (typeof getReplicateApiKey === 'undefined') { function getReplicateApiKey() { return ''; } }
        
        // API 키 마스킹 함수 (콘솔 로그 보안)
        function maskApiKey(key) {
            if (!key || key.length < 8) return '***';
            return key.substring(0, 4) + '***' + key.substring(key.length - 4);
        }
        
        // URL에서 API 키 마스킹 함수
        function maskApiKeyInUrl(url) {
            if (!url || typeof url !== 'string') return url;
            // Gemini API 키 패턴: AIzaSy...
            url = url.replace(/AIzaSy[A-Za-z0-9_-]+/g, function(match) { return maskApiKey(match); });
            // FAL API 키 패턴: UUID:hash
            url = url.replace(/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}:[a-f0-9]+/gi, function(match) { return maskApiKey(match); });
            // key= 파라미터 마스킹
            url = url.replace(/[?&]key=([^&]*)/gi, function(match, key) { return match.replace(key, maskApiKey(key)); });
            return url;
        }
        
        // 에러 객체를 안전하게 마스킹하여 로그 출력용으로 변환하는 함수
        function sanitizeErrorForLogging(error) {
            if (!error) return null;
            var sanitized = {};
            try {
                // error.message
                if (error.message) {
                    sanitized.message = maskApiKeyInUrl(error.message);
                    sanitized.message = sanitized.message.replace(/AIzaSy[A-Za-z0-9_-]+/g, function(match) { return maskApiKey(match); });
                    sanitized.message = sanitized.message.replace(/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}:[a-f0-9]+/gi, function(match) { return maskApiKey(match); });
                }
                // error.response (axios 스타일)
                if (error.response) {
                    sanitized.response = {
                        status: error.response.status,
                        statusText: error.response.statusText,
                        headers: error.response.headers || {}
                    };
                    if (error.response.data) {
                        var dataStr = JSON.stringify(error.response.data);
                        dataStr = maskApiKeyInUrl(dataStr);
                        dataStr = dataStr.replace(/AIzaSy[A-Za-z0-9_-]+/g, function(match) { return maskApiKey(match); });
                        dataStr = dataStr.replace(/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}:[a-f0-9]+/gi, function(match) { return maskApiKey(match); });
                        try {
                            sanitized.response.data = JSON.parse(dataStr);
                        } catch (e) {
                            sanitized.response.data = dataStr;
                        }
                    }
                }
                // error.stack
                if (error.stack) {
                    sanitized.stack = maskApiKeyInUrl(error.stack);
                    sanitized.stack = sanitized.stack.replace(/AIzaSy[A-Za-z0-9_-]+/g, function(match) { return maskApiKey(match); });
                    sanitized.stack = sanitized.stack.replace(/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}:[a-f0-9]+/gi, function(match) { return maskApiKey(match); });
                }
                // 기타 속성
                sanitized.name = error.name || 'Error';
            } catch (e) {
                sanitized = { message: String(error), sanitizationError: 'Failed to sanitize error object' };
            }
            return sanitized;
        }
        
        // HTTP 상태 코드에 대한 설명 반환
        function getHttpStatusDescription(status) {
            var descriptions = {
                400: '잘못된 요청 (400) - 요청 데이터 형식이 올바르지 않습니다.',
                401: '인증 실패 (401) - API 키가 유효하지 않거나 만료되었습니다.',
                403: '권한 없음 (403) - API 키에 권한이 없습니다.',
                404: '리소스를 찾을 수 없음 (404) - 요청한 엔드포인트가 존재하지 않습니다.',
                429: '할당량 초과 (429) - API 사용량 제한에 도달했습니다.',
                500: '서버 오류 (500) - 서버 측 문제가 발생했습니다.',
                502: '게이트웨이 오류 (502) - 서버가 잘못된 응답을 반환했습니다.',
                503: '서비스 사용 불가 (503) - 서버가 일시적으로 사용할 수 없습니다.'
            };
            return descriptions[status] || 'HTTP ' + status + ' - 알 수 없는 오류';
        }
        
        // Gemini API 호출 쓰로틀링 (3초)
        var lastGeminiCallTime = 0;
        var geminiThrottleDelay = 3000; // 3초
        
        // 선택된 키워드를 저장할 변수
        let selectedKeyword = null;
        // 트렌드 키워드 목록 (검색량 내림차순) — 로드 후 AI 제안에 사용
        let currentTrendKeywords = [];
        // 선택된 브랜드를 저장할 변수
        let selectedBrand = 'DV';
        // 선택된 템플릿을 저장할 변수 (A/B/C/D)
        let selectedTemplate = 'A';
        // 선택된 레이아웃 (PC/MO)
        let selectedVariant = 'PC';
        // 마지막 생성된 이미지 URL / 프롬프트 (디벨롭·재생성용)
        let lastGeneratedImageUrl = '';
        let lastGeneratedMoImageUrl = '';
        let lastGeneratedPcImageUrl = '';
        let lastImagePrompt = '';
        let lastDetailInstructions = '';
        let lastAiMode = 'mood';
        let lastImageSeed = null;
        
        // 제품 누끼컷 이미지 (image-to-image 소스: 파일 업로드 또는 URL)
        let referenceImageComposition = '';
        let referenceImageFromFile = null;   // data URL (업로드)
        let referenceImageUrlFromInput = null; // https URL (입력란)
        let referenceImageUrl = null;        // 실제 사용값 = FromFile || FromInput
        let hasReferenceImage = false;
        
        function updateReferenceImage() {
            referenceImageUrl = referenceImageFromFile || referenceImageUrlFromInput || null;
            hasReferenceImage = !!referenceImageUrl;
        }
        let selectedAiMode = null;
        let selectedImageApi = 'fal'; // 기본값: FAL API
        
        // ——— 1. 브랜드 라이브러리 (Style Asset Database) ———
        var BRAND_ASSETS = {
            DV: {
                fullName: 'Duvetica',
                style_keywords: 'Premium lifestyle, Italian elegance, modern resort, soft luxury lighting, refined atmosphere',
                negative_prompt: 'dark night, messy background, urban clutter, text, logo, person'
            },
            ST: {
                fullName: 'Sergio Tacchini',
                style_keywords: 'Classic Italian tennis club, sun-drenched clay court, premium heritage mood, soft cinematic lighting',
                negative_prompt: 'modern city, dark night, messy background, text, logo, person'
            }
        };
        
        // ——— 2. Gemini Creative Director: 키워드 자동 분석 및 창의적 시각화 (fal.ai Flux 최적화) ———
        var GEMINI_CREATIVE_DIRECTOR_SYSTEM = '너는 배너 이미지용 장면을 설계하는 크리에이티브 디렉터다. **이미지 생성 AI는 fal.ai Flux 모델이고, 영어 프롬프트만 잘 이해한다. 한글 키워드·기획의도는 반드시 구체적인 영어 장면 묘사 한 문장으로 변환해라.**\n\n**Flux 모델 특성 이해:**\n- Flux는 구체적이고 상세한 프롬프트를 선호한다\n- 명사와 형용사를 풍부하게 사용하면 더 정확한 결과가 나온다\n- 조명, 색감, 분위기, 구도 등을 명시하면 좋다\n- 추상적이거나 모호한 표현보다는 시각적으로 명확한 묘사가 좋다\n\n**핵심 임무:**\n1. 주어진 키워드를 분석해라. 키워드가 무엇인지(회사명, 브랜드명, 장소명, 제품명, 개념 등) 파악하고, 그 키워드의 본질과 특징을 이해해라.\n2. 키워드와 기획의도를 배너 이미지에 창의적으로 녹여라. 키워드가 시각적으로 바로 연상되는 요소, 그 키워드의 대표적인 특징, 또는 키워드와 관련된 제품·서비스·분위기·맥락을 구체적으로 묘사해라.\n3. **Flux에 최적화된 프롬프트 작성:**\n   - 구체적인 명사 사용 (예: "refrigerator" not "appliance")\n   - 조명과 색감 명시 (예: "soft natural lighting, warm tones")\n   - 분위기와 스타일 명시 (예: "modern, minimalist, professional")\n   - 구도와 배치 명시 (예: "centered composition, spacious background")\n4. 예시(참고용, 절대 하드코딩하지 말고 키워드에 맞게 창의적으로 설계):\n   - 회사명/브랜드명이면 → 그 회사의 대표 제품·서비스·브랜드 특성을 시각적으로 반영\n   - 장소명이면 → 그 장소의 전형적인 배경·분위기·특징\n   - 제품명이면 → 그 제품이 사용되는 맥락·환경\n   - 개념/감성이면 → 그 개념을 시각적으로 표현할 수 있는 장면\n5. **실내·방·인테리어·창문·가구는 사용자가 명시적으로 실내를 요청할 때만 써라. 바다/날씨/바닷가/해변/청량 등이 나오면 무조건 야외 해안·하늘·바다 장면으로.**\n\n응답은 JSON 한 개만, 키 "backgroundPrompt" (string). backgroundPrompt는 영어 한 문장으로만, 키워드와 기획의도가 드러나는 구체적이고 상세하며 Flux에 최적화된 장면을 묘사해라.';
        
        // 상태 메시지 표시
        function setGenerateStatus(msg) {
            var el = document.getElementById('generateStatus');
            if (el) el.textContent = msg || '';
        }
        
        // Gemini Creative Director 호출: 키워드+기획의도+모드+참조이미지 → 배경 전용 영어 프롬프트
        async function callGeminiCreativeDirector(userKeyword, userInstructions, aiMode, hasReferenceImage) {
            // 쓰로틀링 체크: 3초 이내 재호출 방지
            var now = Date.now();
            var timeSinceLastCall = now - lastGeminiCallTime;
            if (timeSinceLastCall < geminiThrottleDelay) {
                var waitTime = Math.ceil((geminiThrottleDelay - timeSinceLastCall) / 1000);
                console.warn('⏱️ Gemini API 호출 쓰로틀링: ' + waitTime + '초 후 다시 시도하세요.');
                return ''; // 빈 문자열 반환하여 폴백 프롬프트 사용
            }
            lastGeminiCallTime = now;
            
            var apiKey = getGeminiApiKey();
            var res = null;
            try {
                if (apiKey && !API_BASE) {
                    // 서버 없이: config.js 키로 브라우저에서 Gemini 직접 호출
                    console.log('🔵 [진행 단계] Gemini API 호출 중... (브라우저 직접)');
                    var modeInstruction = '';
                    if (aiMode === 'product') modeInstruction = ' Focus: product-centered commercial photography. The scene should showcase a product as the main subject.';
                    else if (aiMode === 'person') modeInstruction = ' Focus: person/model-centered commercial photography. The scene should feature a person or model as the main subject.';
                    var refImageNote = hasReferenceImage ? '\n\n**CRITICAL: A reference product/subject image will be provided, but the KEYWORD is the PRIMARY and DOMINANT theme. Your backgroundPrompt must describe ONLY the keyword-themed background scene that will COMPLETELY REPLACE the reference image\'s background. Do NOT describe the product itself - only describe the environment, setting, scene, atmosphere, lighting, colors, mood that represents the keyword. The product from the reference image will be placed into this background later. Focus on creating a rich, detailed background scene that represents the keyword theme - NOT a simple or plain background.' : '';
                    var userContent = 'Analyze this keyword and create a creative visual scene for a banner image optimized for fal.ai Flux model.\n\nKeyword: "' + (userKeyword || '') + '"\nCampaign intent (기획 의도 및 강조점): "' + (userInstructions || '') + '"' + refImageNote + '\n\n' + modeInstruction + '\n\n**Your task (optimized for Flux):**\n1. Analyze what this keyword represents (company/brand, place, product, concept, etc.)\n2. Understand the essence and characteristics of this keyword\n3. Design a creative visual scene that incorporates the keyword and campaign intent into the banner' + (hasReferenceImage ? '\n4. **If a reference product/subject image is provided:** Describe ONLY the background environment, setting, atmosphere, lighting, colors, mood that represents the keyword theme. Do NOT describe the product itself - the product will be added separately. Focus on creating a complete, detailed background scene that the keyword represents.' : '') + '\n4. **Write a detailed, specific English prompt optimized for Flux:**\n   - Use concrete nouns and descriptive adjectives\n   - Specify lighting, color tones, mood, and style\n   - Include composition and spatial arrangement details\n   - Make it visually clear and immediately recognizable\n   - ' + (hasReferenceImage ? 'Describe ONLY the background scene, environment, setting - NOT any products or subjects' : '') + '\n5. Be creative and thoughtful.\n\n**Important:** Flux works best with detailed, specific descriptions. One sentence only, but make it detailed and specific.';
                    res = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=' + apiKey, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            systemInstruction: { parts: [{ text: GEMINI_CREATIVE_DIRECTOR_SYSTEM }] },
                            contents: [{ role: 'user', parts: [{ text: userContent }] }],
                            generationConfig: { response_mime_type: 'application/json', maxOutputTokens: 256 }
                        })
                    });
                    var data = await res.json().catch(function() { return {}; });
                    if (!res.ok) throw new Error(data.error?.message || 'Gemini API 오류: ' + res.status);
                    var text = (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0]) ? data.candidates[0].content.parts[0].text : '';
                    text = (text || '').replace(/^```(?:json)?\s*/i, '').replace(/\s*```$/i, '').trim();
                    var parsed = (function() { try { var m = text.match(/\{[\s\S]*\}/); return m ? JSON.parse(m[0]) : {}; } catch (e) { return {}; } })();
                    var result = (parsed.backgroundPrompt && String(parsed.backgroundPrompt).trim()) ? String(parsed.backgroundPrompt).trim() : '';
                    console.log('✅ [진행 단계] Gemini 키워드 분석 완료');
                    return result;
                }
                // 서버 사용 시
                console.log('🔵 [진행 단계] Gemini API 호출 중... (서버 /api/gemini)');
                res = await fetch(API_BASE + '/api/gemini', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userKeyword: userKeyword || '',
                        userInstructions: userInstructions || '',
                        aiMode: aiMode || null,
                        hasReferenceImage: !!hasReferenceImage
                    })
                });
                var data = await res.json().catch(function() { return {}; });
                if (!res.ok) {
                    console.error('❌ Gemini API 응답 오류:', res.status, data);
                    throw new Error(data.error || 'Gemini API 오류: ' + res.status);
                }
                var result = (data.backgroundPrompt && String(data.backgroundPrompt).trim()) ? String(data.backgroundPrompt).trim() : '';
                console.log('✅ [진행 단계] Gemini 키워드 분석 완료');
                return result;
            } catch (e) {
                console.error('❌ Gemini Creative Director 호출 실패');
                
                // 상세 에러 정보 출력 (API 키 마스킹)
                var sanitizedError = sanitizeErrorForLogging(e);
                if (sanitizedError) {
                    console.error('📝 에러 메시지:', sanitizedError.message);
                    if (sanitizedError.response) {
                        console.error('📊 HTTP 상태 코드:', sanitizedError.response.status, '(' + sanitizedError.response.statusText + ')');
                        console.error('📋 상태 코드 설명:', getHttpStatusDescription(sanitizedError.response.status));
                        if (sanitizedError.response.data) {
                            console.error('📄 응답 데이터:', sanitizedError.response.data);
                        }
                    }
                    if (sanitizedError.stack) {
                        console.error('🔍 에러 스택 (API 키 마스킹됨):', sanitizedError.stack);
                    }
                } else {
                    // sanitizeErrorForLogging이 실패한 경우 기본 마스킹
                    var errorMsg = e.message || String(e);
                    errorMsg = maskApiKeyInUrl(errorMsg);
                    errorMsg = errorMsg.replace(/AIzaSy[A-Za-z0-9_-]+/g, function(match) { return maskApiKey(match); });
                    errorMsg = errorMsg.replace(/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}:[a-f0-9]+/gi, function(match) { return maskApiKey(match); });
                    console.error('📝 에러 메시지:', errorMsg);
                }
                
                // res 객체가 있는 경우 상태 코드 출력
                if (res) {
                    console.error('📊 HTTP 상태 코드:', res.status, '(' + res.statusText + ')');
                    console.error('📋 상태 코드 설명:', getHttpStatusDescription(res.status));
                }
                
                // 전체 에러 객체 출력 (순환 참조 방지)
                    try {
                        var errorObj = {
                            name: e.name,
                            message: sanitizedError ? sanitizedError.message : (e.message || String(e)),
                            stack: sanitizedError ? sanitizedError.stack : (e.stack || '')
                        };
                        console.error('📦 전체 에러 객체 (API 키 마스킹됨):');
                        console.error('   - 에러 이름:', errorObj.name);
                        console.error('   - 에러 메시지:', errorObj.message);
                        if (errorObj.stack) {
                            console.error('   - 에러 스택:', errorObj.stack);
                        }
                        console.error('   - 전체 객체:', errorObj);
                    } catch (err) {
                        console.error('⚠️ 에러 객체 직렬화 실패:', err);
                    }
                
                console.warn('🔄 키워드를 직접 분석하여 폴백 프롬프트를 생성합니다.');
                return '';
            }
        }
        
        // ——— 3. 프롬프트 퓨전: 선택된 키워드 + 기획 의도·강조점 + 모드 반영 (Gemini 실패 시 영어 폴백으로 실내 방지) ———
        function fusePrompt(selectedBrand, userKeyword, userInstructions, geminiBackgroundPrompt, isMo, aiMode) {
            var base = 'High quality, 8k, professional.';
            var themeFirst = (geminiBackgroundPrompt && String(geminiBackgroundPrompt).trim()) ? String(geminiBackgroundPrompt).trim() : '';
            var kw = (userKeyword && String(userKeyword).trim()) ? 'Theme and setting: ' + String(userKeyword).trim() + '.' : '';
            var instruction = (userInstructions && String(userInstructions).trim()) ? String(userInstructions).trim() : '';
            var modePrompt = '';
            if (aiMode === 'product') {
                modePrompt = 'Product-centered composition, product as main subject, commercial product photography.';
            } else if (aiMode === 'person') {
                modePrompt = 'Person-centered composition, model or person as main subject, commercial portrait photography.';
            }
            // aiMode가 null이거나 빈 값이면 modePrompt는 빈 문자열로 유지 (키워드와 기획 의도만으로 생성)
            var fallback = '';
            // Gemini가 실패했을 때 키워드를 직접 분석해서 폴백 생성
            if (!themeFirst && (kw || instruction)) {
                var keywordStr = (userKeyword || '').toLowerCase();
                var hasBeach = /바다|바닷가|해변|청량|날씨|부산|해안|ocean|beach|seaside|sea\b/i.test((userKeyword || '') + ' ' + (userInstructions || ''));
                if (hasBeach) {
                    fallback = 'Outdoor scene: refreshing seaside, ocean view, beach, clear sky, coastal vibe. No indoor, no room, no furniture.';
                } else if (/lg전자|lg\s*전자|lg\s*electronics/i.test(keywordStr)) {
                    fallback = 'Modern LG electronics showroom, home appliances display, smart home technology, TVs, refrigerators, washing machines, tech products, contemporary retail environment, professional lighting.';
                } else if (/삼성전자|samsung\s*전자|samsung\s*electronics/i.test(keywordStr)) {
                    fallback = 'Samsung electronics showcase, smartphones, TVs, home appliances, technology innovation, modern tech products, sleek retail space, professional commercial photography.';
                } else if (/애플|apple/i.test(keywordStr)) {
                    fallback = 'Apple products display, iPhone, MacBook, iPad, minimalist tech design, modern technology, clean retail environment, professional product photography.';
                } else if (/나이키|nike/i.test(keywordStr)) {
                    fallback = 'Nike sportswear showcase, athletic gear, sports equipment, active lifestyle, athletic performance, modern sports retail, dynamic commercial photography.';
                } else if (/대학교|university|대학/i.test(keywordStr)) {
                    fallback = 'University campus, academic building, library, modern educational institution, student environment, professional academic setting.';
                }
            }
            var composition = isMo
                ? 'Leave top 60% of frame empty for typography.'
                : 'Leave left 60% of frame empty for typography.';
            var parts = [base, themeFirst, fallback, modePrompt, kw, instruction, composition].filter(Boolean);
            return parts.join(' ');
        }
        
        // 프롬프트 + 브랜드/키워드 복사용 결과 (Gemini Creative Director + 퓨전)
        async function getPromptResult(selectedBrand, selectedKeyword, campaignIntent, aiMode, hasReferenceImage) {
            console.log('🔵 [진행 단계] 프롬프트 생성 시작');
            setGenerateStatus('크리에이티브 디렉터가 배경을 설계하는 중...');
            
            // 참조 이미지가 있을 경우 크기 확인 및 경고
            if (hasReferenceImage && referenceImageUrl) {
                var base64Length = referenceImageUrl.length;
                var estimatedSizeKB = Math.round((base64Length - 22) * 0.75 / 1024); // data:image/jpeg;base64, 제외
                console.log('📊 참조 이미지 크기:', estimatedSizeKB + ' KB (base64)');
                if (estimatedSizeKB > 500) {
                    console.warn('⚠️ 참조 이미지가 큽니다 (' + estimatedSizeKB + ' KB). API 요청 크기가 클 수 있습니다.');
                }
            }
            
            var geminiBackground = await callGeminiCreativeDirector(selectedKeyword, campaignIntent, aiMode, hasReferenceImage);
            console.log('🟡 [진행 단계] 프롬프트 퓨전 중...');
            var imagePromptPc = fusePrompt(selectedBrand, selectedKeyword, campaignIntent, geminiBackground, false, aiMode);
            var imagePromptMo = fusePrompt(selectedBrand, selectedKeyword, campaignIntent, geminiBackground, true, aiMode);
            console.log('✅ [진행 단계] 프롬프트 생성 완료');
            var brand = BRAND_ASSETS[selectedBrand];
            var brandCopy = (brand && brand.fullName) ? brand.fullName + ' 26SS 컬렉션' : (selectedBrand || '') + ' 26SS 컬렉션';
            return {
                imagePrompt: imagePromptPc,
                imagePromptMo: imagePromptMo,
                brandCopy: brandCopy,
                keywordCopy: selectedKeyword || ''
            };
        }
        
        // ——— 4. fal.ai Flux 이미지 생성 (키워드·지침 우선, 참조 이미지 있으면 2단계 접근: 배경 먼저 생성 후 제품 합성) ———
        function fetchNanoBananaImage(selectedBrand, fusedPrompt, seed, isMo, productImageUrl) {
            var imageType = isMo ? 'MO' : 'PC';
            console.log('🟡 [진행 단계] FAL API 호출 중... (' + imageType + ' 이미지 생성)');
            
            var imageSize = isMo ? 'portrait_16_9' : 'landscape_16_9';
            var negativePrompt = 'text, watermark, blurry, distorted, deformed';
            var apiKey = getFalApiKey();
            var useDirectFal = apiKey && !API_BASE;
            // 서버 없이 쓰는 환경(GitHub Pages 등)에서 FAL 키도 없으면 /api/... 요청 시 405 발생 → 미리 안내
            if (!API_BASE && !apiKey) {
                return Promise.reject(new Error('서버 없이 사용하려면 config.js에 FAL API 키를 넣어 주세요. (fal.ai 가입 후 API 키 발급) 또는 로컬에서 node server.js를 실행한 뒤 사용하세요.'));
            }
            
            // 참조 이미지(파일 data URL 또는 이미지 URL)가 있으면 2단계: 키워드 배경 생성 → 제품 합성
            if (productImageUrl) {
                var isUrl = typeof productImageUrl === 'string' && /^https?:\/\//i.test(productImageUrl.trim());
                console.log('🔄 [2단계 접근] 참조 이미지 사용 (' + (isUrl ? 'URL' : '업로드') + ') → 1단계: 키워드 배경 생성...');
                
                var backgroundPrompt = fusedPrompt + ' This is a background scene only. No products, no subjects, no objects in the foreground. Just the environment, setting, atmosphere, and scene that represents the keyword theme. The background should fill the entire image.';
                var backgroundNegativePrompt = negativePrompt + ', product, object, subject, person, item, thing, foreground object, main subject';
                var body1 = { prompt: backgroundPrompt, image_size: imageSize, negative_prompt: backgroundNegativePrompt, seed: seed != null ? seed : undefined };
                
                var url1 = useDirectFal ? 'https://fal.run/fal-ai/flux/dev' : (API_BASE + '/api/fal/text-to-image');
                var opts1 = useDirectFal ? { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': 'Key ' + apiKey }, body: JSON.stringify(body1) } : { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body1) };
                return fetch(url1, opts1)
                .then(function(r) {
                    if (!r.ok) {
                        return r.json().then(function(errorData) {
                            throw { response: r, errorData: errorData };
                        }).catch(function() {
                            throw { response: r, errorData: { error: { message: 'Unknown error' } } };
                        });
                    }
                    return r.json();
                })
                .then(function(data) {
                    var backgroundUrl = (data && data.images && data.images[0] && data.images[0].url) ? data.images[0].url : null;
                    if (!backgroundUrl) throw new Error('배경 이미지 생성 실패');
                    
                    console.log('✅ [2단계 접근] 1단계 완료: 배경 생성됨');
                    console.log('🔄 [2단계 접근] 2단계: 배경 위에 제품 합성...');
                    
                    // 2단계: 제품 이미지를 참조로 사용하되, 배경은 완전히 무시하고 생성된 배경으로 교체
                    // 핵심: 제품 이미지의 제품만 추출하고, 배경은 생성된 배경으로 완전히 교체
                    var imageUrlForApi = (typeof productImageUrl === 'string' && productImageUrl.trim()) ? productImageUrl.trim() : productImageUrl;
                    var strength = 0.12; // 매우 낮은 strength로 제품만 유지하고 배경은 완전히 교체
                    
                    // 프롬프트: 생성된 배경을 강조하고, 제품은 참조 이미지에서만 가져오도록
                    // 배경 교체를 매우 강력하게 지시
                    var compositePrompt = fusedPrompt + ' IGNORE AND COMPLETELY REMOVE the background from the reference image. REPLACE it entirely with this keyword-themed background scene. Extract ONLY the main product/subject (clothing, item, object) from the reference image and place it naturally within the new keyword-themed background. The original background (black, grey, white, or any solid color) must be completely gone and replaced with the keyword scene. The product should appear as if it was photographed in this new environment. Do not preserve any part of the original background.';
                    
                    var body2 = { image_url: imageUrlForApi, prompt: compositePrompt, strength: strength, image_size: imageSize, negative_prompt: negativePrompt + ', plain background, grey background, simple background, black background, white background, neutral background, product photography background, studio background, solid color background, monochrome background, uniform background, empty background, void background', seed: seed != null ? seed : undefined };
                    var url2 = useDirectFal ? 'https://fal.run/fal-ai/flux/dev/image-to-image' : (API_BASE + '/api/fal/image-to-image');
                    var opts2 = useDirectFal ? { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': 'Key ' + apiKey }, body: JSON.stringify(body2) } : { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body2) };
                    return fetch(url2, opts2)
                    .then(function(r2) {
                        if (!r2.ok) {
                            return r2.json().then(function(errorData) {
                                throw { response: r2, errorData: errorData };
                            }).catch(function() {
                                throw { response: r2, errorData: { error: { message: 'Unknown error' } } };
                            });
                        }
                        return r2.json();
                    })
                    .then(function(data2) {
                        var compositeUrl = (data2 && data2.images && data2.images[0] && data2.images[0].url) ? data2.images[0].url : null;
                        if (!compositeUrl) {
                            console.warn('⚠️ 제품 합성 실패, 배경만 반환');
                            return backgroundUrl;
                        }
                        console.log('✅ [2단계 접근] 2단계 완료: 제품 합성됨');
                        return compositeUrl;
                    })
                    .catch(function(err2) {
                        console.warn('⚠️ 제품 합성 단계 오류 (배경만 반환):', err2 && (err2.message || err2.errorData));
                        return backgroundUrl;
                    });
                })
                .then(function(finalUrl) {
                    console.log('✅ [진행 단계] FAL 이미지 생성 완료 (' + imageType + ')');
                    return finalUrl;
                })
                .catch(function(err) {
                    console.error('❌ FAL API 이미지 생성 실패 (' + imageType + ')');
                    // 에러 처리 (기존 코드와 동일)
                    var sanitizedError = sanitizeErrorForLogging(err);
                    if (sanitizedError) {
                        console.error('📝 에러 메시지:', sanitizedError.message);
                        if (sanitizedError.response) {
                            console.error('📊 HTTP 상태 코드:', sanitizedError.response.status, '(' + sanitizedError.response.statusText + ')');
                            console.error('📋 상태 코드 설명:', getHttpStatusDescription(sanitizedError.response.status));
                            if (sanitizedError.response.data) {
                                console.error('📄 응답 데이터:', sanitizedError.response.data);
                            }
                        }
                    }
                    return 'https://picsum.photos/seed/fallback/1920/1080';
                });
            } else {
                // 참조 이미지 없으면 text-to-image — 서버 /api/fal/text-to-image
                var body = { prompt: fusedPrompt, image_size: imageSize, negative_prompt: negativePrompt };
                if (seed != null) body.seed = seed;
                var responseObj = null;
                var url0 = useDirectFal ? 'https://fal.run/fal-ai/flux/dev' : (API_BASE + '/api/fal/text-to-image');
                var opts0 = useDirectFal ? { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': 'Key ' + apiKey }, body: JSON.stringify(body) } : { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) };
                return fetch(url0, opts0)
                    .then(function(r) {
                        responseObj = r;
                        if (!r.ok) {
                            return r.json().then(function(errorData) {
                                throw { response: r, errorData: errorData };
                            }).catch(function() {
                                throw { response: r, errorData: { error: { message: 'Unknown error' } } };
                            });
                        }
                        console.log('✅ [진행 단계] FAL API 응답 수신 완료 (' + imageType + ')');
                        return r.json();
                    })
                    .then(function(data) {
                        console.log('🟡 [진행 단계] 응답 데이터 파싱 중... (' + imageType + ')');
                        var url = (data && data.images && data.images[0] && data.images[0].url) ? data.images[0].url : null;
                        if (!url) throw new Error('fal.ai 이미지 URL 없음');
                        console.log('✅ [진행 단계] FAL 이미지 생성 완료 (' + imageType + ')');
                        return url;
                    })
                    .catch(function(err) {
                        console.error('❌ FAL API 이미지 생성 실패 (' + imageType + ')');
                        
                        // 상세 에러 정보 출력
                        var sanitizedError = sanitizeErrorForLogging(err);
                        if (sanitizedError) {
                            console.error('📝 에러 메시지:', sanitizedError.message);
                            if (sanitizedError.response) {
                                console.error('📊 HTTP 상태 코드:', sanitizedError.response.status, '(' + sanitizedError.response.statusText + ')');
                                console.error('📋 상태 코드 설명:', getHttpStatusDescription(sanitizedError.response.status));
                                if (sanitizedError.response.data) {
                                    console.error('📄 응답 데이터:', sanitizedError.response.data);
                                }
                            }
                        }
                        
                        // responseObj가 있는 경우 (fetch 성공했지만 !r.ok인 경우)
                        if (responseObj) {
                            console.error('📊 HTTP 상태 코드:', responseObj.status, '(' + responseObj.statusText + ')');
                            console.error('📋 상태 코드 설명:', getHttpStatusDescription(responseObj.status));
                        }
                        
                        // err.errorData가 있는 경우 (응답 본문 파싱 성공)
                        if (err && err.errorData) {
                            var safeErrorData = JSON.stringify(err.errorData).replace(/AIzaSy[A-Za-z0-9_-]+/g, function(match) { return maskApiKey(match); });
                            safeErrorData = safeErrorData.replace(/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}:[a-f0-9]+/gi, function(match) { return maskApiKey(match); });
                            try {
                                console.error('📄 응답 데이터 (API 키 마스킹됨):', JSON.parse(safeErrorData));
                            } catch (e) {
                                console.error('📄 응답 데이터:', safeErrorData);
                            }
                        }
                        
                        // 전체 에러 객체 출력
                        try {
                            var errorObj = {
                                name: err.name || 'Error',
                                message: sanitizedError ? sanitizedError.message : (err.message || String(err)),
                                response: sanitizedError ? sanitizedError.response : (err.response || null),
                                errorData: err.errorData || null
                            };
                            console.error('📦 전체 에러 객체 (API 키 마스킹됨):', errorObj);
                        } catch (e) {
                            console.error('⚠️ 에러 객체 직렬화 실패');
                        }
                        
                    return 'https://picsum.photos/seed/fallback/1920/1080';
                });
            }
        }
        
        // ——— 5. Replicate API 이미지 생성 (ControlNet으로 정확한 배경 교체) ———
        function fetchReplicateImage(selectedBrand, fusedPrompt, seed, isMo, productImageUrl, retried) {
            if (!API_BASE) {
                return Promise.reject(new Error('Replicate는 서버(node server.js) 실행 후 사용할 수 있습니다. 지금은 FAL API를 선택하거나, 로컬에서 node server.js를 실행해 주세요.'));
            }
            var imageType = isMo ? 'MO' : 'PC';
            if (retried) console.log('🟡 [진행 단계] Replicate API 재시도 중... (' + imageType + ')');
            else console.log('🟡 [진행 단계] Replicate API 호출 중... (' + imageType + ' 이미지 생성)');
            if (fusedPrompt && fusedPrompt.trim()) {
                console.log('📝 Replicate에 전달하는 프롬프트:', fusedPrompt.trim().substring(0, 200) + (fusedPrompt.length > 200 ? '...' : ''));
            } else {
                console.warn('⚠️ Replicate 프롬프트가 비어 있습니다. 키워드 반영 이미지가 나오지 않을 수 있습니다.');
            }
            // Replicate API 키는 서버(.env)에서 관리. 서버에 없으면 503 반환
            
            // 참조 이미지가 있으면 2단계 접근 (배경 생성 → 제품 합성)
            if (productImageUrl) {
                console.log('🔄 [Replicate 2단계 접근] 1단계: 키워드 배경 먼저 생성...');
                
                // 1단계: 키워드 배경만 먼저 생성
                var backgroundPrompt = fusedPrompt + ' This is a background scene only. No products, no subjects, no objects in the foreground. Just the environment, setting, atmosphere, and scene that represents the keyword theme. The background should fill the entire image.';
                
                // 서버 프록시를 통해 Replicate API 호출 (CORS 문제 해결)
                var proxyUrl = API_BASE + '/api/replicate';
                return fetch(proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        version: "black-forest-labs/flux-dev",
                        input: {
                            prompt: backgroundPrompt,
                            aspect_ratio: isMo ? '9:16' : '16:9',
                            output_format: 'webp',
                            seed: seed != null ? seed : undefined
                        }
                    })
                })
                .then(function(r) {
                    if (!r.ok) {
                        return r.json().then(function(errorData) {
                            throw { response: r, errorData: errorData };
                        }).catch(function() {
                            throw { response: r, errorData: { error: { message: 'Unknown error' } } };
                        });
                    }
                    return r.json();
                })
                .then(function(data) {
                    // Replicate는 비동기 처리이므로 prediction을 확인해야 함
                    var predictionId = data.id;
                    console.log('✅ [Replicate 2단계 접근] 1단계 예측 생성됨:', predictionId);
                    
                    // 결과를 기다리는 함수
                    function waitForPrediction(predictionId) {
                        return new Promise(function(resolve, reject) {
                            function checkStatus() {
                                // 서버 프록시를 통해 상태 확인
                                fetch(API_BASE + '/api/replicate/' + predictionId)
                                .then(function(r) { return r.json(); })
                                .then(function(prediction) {
                                    if (prediction.status === 'succeeded') {
                                        var backgroundUrl = prediction.output && prediction.output[0] ? prediction.output[0] : null;
                                        if (!backgroundUrl) {
                                            reject(new Error('배경 이미지 생성 실패'));
                                            return;
                                        }
                                        console.log('✅ [Replicate 2단계 접근] 1단계 완료: 배경 생성됨');
                                        console.log('🔄 [Replicate 2단계 접근] 2단계: 배경 위에 제품 합성...');
                                        
                                        // 2단계: ControlNet으로 배경 위에 제품 합성
                                        var imageUrlForApi = (typeof productImageUrl === 'string' && productImageUrl.trim()) ? productImageUrl.trim() : productImageUrl;
                                        var compositePrompt = fusedPrompt + ' Place the product/subject from the reference image naturally into this background scene. The product should blend seamlessly into the environment. Keep the background scene unchanged - only add the product from the reference image.';
                                        
                                        // 서버 프록시를 통해 Replicate API 호출
                                        fetch(API_BASE + '/api/replicate', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify({
                                                version: "runvnc/controlnet2",
                                                input: {
                                                    image: imageUrlForApi,
                                                    prompt: compositePrompt,
                                                    structure: "background_mask",
                                                    strength: 0.8,
                                                    scale: 7.5
                                                }
                                            })
                                        })
                                        .then(function(r2) {
                                            if (!r2.ok) {
                                                return r2.json().then(function(errorData) {
                                                    throw { response: r2, errorData: errorData };
                                                });
                                            }
                                            return r2.json();
                                        })
                                        .then(function(data2) {
                                            var compositePredictionId = data2.id;
                                            return waitForPrediction(compositePredictionId);
                                        })
                                        .then(function(finalUrl) {
                                            console.log('✅ [Replicate 2단계 접근] 2단계 완료: 제품 합성됨');
                                            resolve(finalUrl);
                                        })
                                        .catch(function(err) {
                                            console.warn('⚠️ 제품 합성 실패, 배경만 반환');
                                            resolve(backgroundUrl);
                                        });
                                    } else if (prediction.status === 'failed') {
                                        reject(new Error(prediction.error || '예측 실패'));
                                    } else {
                                        // 아직 처리 중이면 1초 후 다시 확인
                                        setTimeout(checkStatus, 1000);
                                    }
                                })
                                .catch(reject);
                            }
                            checkStatus();
                        });
                    }
                    
                    return waitForPrediction(predictionId);
                })
                .then(function(finalUrl) {
                    console.log('✅ [진행 단계] Replicate 이미지 생성 완료 (' + imageType + ')');
                    return finalUrl;
                })
                .catch(function(err) {
                    console.error('❌ Replicate API 이미지 생성 실패 (' + imageType + ')');
                    var sanitizedError = sanitizeErrorForLogging(err);
                    if (sanitizedError) {
                        console.error('📝 에러 메시지:', sanitizedError.message);
                        if (sanitizedError.response) {
                            console.error('📊 HTTP 상태 코드:', sanitizedError.response.status);
                        }
                    }
                    if (err.response && err.response.status === 429 && !retried) {
                        console.warn('⏳ 429 한도 초과. 35초 후 자동 재시도 (1회)...');
                        if (typeof setGenerateStatus === 'function') setGenerateStatus('Replicate 한도 초과. 35초 후 자동 재시도...');
                        return new Promise(function(go) { setTimeout(go, 35000); }).then(function() {
                            if (typeof setGenerateStatus === 'function') setGenerateStatus('재시도 중...');
                            return fetchReplicateImage(selectedBrand, fusedPrompt, seed, isMo, productImageUrl, true);
                        });
                    }
                    return Promise.reject(err);
                });
            } else {
                // 참조 이미지 없으면 배경만 생성
                // 서버 프록시를 통해 Replicate API 호출
                return fetch(API_BASE + '/api/replicate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        version: "black-forest-labs/flux-dev",
                        input: {
                            prompt: fusedPrompt,
                            aspect_ratio: isMo ? '9:16' : '16:9',
                            output_format: 'webp',
                            seed: seed != null ? seed : undefined
                        }
                    })
                })
                .then(function(r) {
                    if (!r.ok) {
                        return r.json().then(function(errorData) {
                            throw { response: r, errorData: errorData };
                        }).catch(function() {
                            throw { response: r, errorData: { error: '서버 응답 파싱 실패' } };
                        });
                    }
                    return r.json();
                })
                .catch(function(err) {
                    // 네트워크 오류 (서버 미실행 등)
                    if (err.message && (err.message.includes('Failed to fetch') || err.message.includes('ERR_CONNECTION_REFUSED'))) {
                        console.error('❌ 서버 연결 실패: server.js가 실행 중인지 확인하세요.');
                        console.error('💡 해결 방법: 터미널에서 "node server.js" 실행 후 다시 시도하세요.');
                        console.log('💡 자동으로 FAL API로 폴백합니다.');
                        return fetchNanoBananaImage(selectedBrand, fusedPrompt, seed, isMo, productImageUrl);
                    }
                    throw err;
                })
                .then(function(data) {
                    // data가 이미 FAL API 결과(URL 문자열)인 경우
                    if (typeof data === 'string') {
                        return data;
                    }
                    var predictionId = data.id;
                    function waitForPrediction(predictionId) {
                        return new Promise(function(resolve, reject) {
                            function checkStatus() {
                                // 서버 프록시를 통해 상태 확인
                                fetch(API_BASE + '/api/replicate/' + predictionId)
                                .then(function(r) { return r.json(); })
                                .then(function(prediction) {
                                    if (prediction.status === 'succeeded') {
                                        var url = prediction.output && prediction.output[0] ? prediction.output[0] : null;
                                        if (!url) reject(new Error('이미지 URL 없음'));
                                        else resolve(url);
                                    } else if (prediction.status === 'failed') {
                                        reject(new Error(prediction.error || '예측 실패'));
                                    } else {
                                        setTimeout(checkStatus, 1000);
                                    }
                                })
                                .catch(function(err) {
                                    if (err.message && (err.message.includes('Failed to fetch') || err.message.includes('ERR_CONNECTION_REFUSED'))) {
                                        console.error('❌ 서버 연결 실패: waitForPrediction 중');
                                        console.log('💡 자동으로 FAL API로 폴백합니다.');
                                        fetchNanoBananaImage(selectedBrand, fusedPrompt, seed, isMo, productImageUrl)
                                            .then(resolve)
                                            .catch(reject);
                                    } else {
                                        reject(err);
                                    }
                                });
                            }
                            checkStatus();
                        });
                    }
                    return waitForPrediction(predictionId);
                })
                .then(function(url) {
                    console.log('✅ [진행 단계] Replicate 이미지 생성 완료 (' + imageType + ')');
                    return url;
                })
                .catch(function(err) {
                    console.error('❌ Replicate API 이미지 생성 실패 (' + imageType + ')');
                    if (err.message && (err.message.includes('Failed to fetch') || err.message.includes('ERR_CONNECTION_REFUSED'))) {
                        console.error('⚠️ 서버 연결 실패: server.js가 실행 중인지 확인하세요. (node server.js)');
                        console.error('💡 자동으로 FAL API로 폴백합니다.');
                        return fetchNanoBananaImage(selectedBrand, fusedPrompt, seed, isMo, productImageUrl);
                    }
                    if (err.response && err.response.status === 429 && !retried) {
                        console.warn('⏳ 429 한도 초과. 35초 후 자동 재시도 (1회)...');
                        if (typeof setGenerateStatus === 'function') setGenerateStatus('Replicate 한도 초과. 35초 후 자동 재시도...');
                        return new Promise(function(go) { setTimeout(go, 35000); }).then(function() {
                            if (typeof setGenerateStatus === 'function') setGenerateStatus('재시도 중...');
                            return fetchReplicateImage(selectedBrand, fusedPrompt, seed, isMo, productImageUrl, true);
                        });
                    }
                    return Promise.reject(err);
                });
            }
        }
        
        // fal.ai Flux Image-to-Image (디벨롭: 현재 이미지 URL + 피드백, strength 0.45)
        function fetchFluxImageToImage(imageUrl, prompt, strength) {
            var falKey = getFalApiKey();
            var useDirect = falKey && !API_BASE;
            if (!API_BASE && !falKey) return Promise.reject(new Error('서버 없이 사용하려면 config.js에 FAL API 키를 넣어 주세요. 또는 node server.js를 실행하세요.'));
            console.log('🟡 [진행 단계] FAL API 이미지 디벨롭 중...' + (useDirect ? ' (직접 fal.run)' : ' (서버 /api/fal/image-to-image)'));
            strength = strength == null ? 0.45 : Math.min(1, Math.max(0, strength));
            var body = { image_url: imageUrl, prompt: prompt || 'Keep the same composition, improve quality.', strength: strength };
            var url = useDirect ? 'https://fal.run/fal-ai/flux/dev/image-to-image' : (API_BASE + '/api/fal/image-to-image');
            var opts = useDirect ? { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': 'Key ' + falKey }, body: JSON.stringify(body) } : { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) };
            var responseObj = null;
            return fetch(url, opts)
                .then(function(r) {
                    responseObj = r;
                    if (!r.ok) {
                        return r.json().then(function(errorData) {
                            throw { response: r, errorData: errorData };
                        }).catch(function() {
                            throw { response: r, errorData: { error: { message: 'Unknown error' } } };
                        });
                    }
                    console.log('✅ [진행 단계] FAL API 디벨롭 응답 수신 완료');
                    return r.json();
                })
                .then(function(data) {
                    console.log('🟡 [진행 단계] 디벨롭 응답 데이터 파싱 중...');
                    var url = (data && data.images && data.images[0] && data.images[0].url) ? data.images[0].url : null;
                    if (!url) throw new Error('fal.ai image-to-image URL 없음');
                    console.log('✅ [진행 단계] FAL 이미지 디벨롭 완료');
                    return url;
                })
                .catch(function(err) {
                    console.error('❌ FAL API 이미지 디벨롭 실패');
                    
                    // 상세 에러 정보 출력
                    var sanitizedError = sanitizeErrorForLogging(err);
                    if (sanitizedError) {
                        console.error('📝 에러 메시지:', sanitizedError.message);
                        if (sanitizedError.response) {
                            console.error('📊 HTTP 상태 코드:', sanitizedError.response.status, '(' + sanitizedError.response.statusText + ')');
                            console.error('📋 상태 코드 설명:', getHttpStatusDescription(sanitizedError.response.status));
                            if (sanitizedError.response.data) {
                                console.error('📄 응답 데이터:', sanitizedError.response.data);
                            }
                        }
                    }
                    
                    if (responseObj) {
                        console.error('📊 HTTP 상태 코드:', responseObj.status, '(' + responseObj.statusText + ')');
                        console.error('📋 상태 코드 설명:', getHttpStatusDescription(responseObj.status));
                    }
                    
                    if (err && err.errorData) {
                        var safeErrorData = JSON.stringify(err.errorData).replace(/AIzaSy[A-Za-z0-9_-]+/g, function(match) { return maskApiKey(match); });
                        safeErrorData = safeErrorData.replace(/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}:[a-f0-9]+/gi, function(match) { return maskApiKey(match); });
                        try {
                            console.error('📄 응답 데이터 (API 키 마스킹됨):', JSON.parse(safeErrorData));
                        } catch (e) {
                            console.error('📄 응답 데이터:', safeErrorData);
                        }
                    }
                    
                    try {
                        var errorObj = {
                            name: err.name || 'Error',
                            message: sanitizedError ? sanitizedError.message : (err.message || String(err)),
                            response: sanitizedError ? sanitizedError.response : (err.response || null),
                            errorData: err.errorData || null
                        };
                        console.error('📦 전체 에러 객체 (API 키 마스킹됨):', errorObj);
                    } catch (e) {
                        console.error('⚠️ 에러 객체 직렬화 실패');
                    }
                    
                    return null;
                });
        }
        
        // MO 시안을 기준으로 PC 시안 생성 (같은 느낌 유지, 구도만 가로로 확장. 인물/제품 동일)
        function fetchPcFromMoImage(moImageUrl, seed) {
            if (!moImageUrl) return Promise.resolve('');
            var falKey = getFalApiKey();
            var useDirect = falKey && !API_BASE;
            if (!API_BASE && !falKey) return Promise.reject(new Error('서버 없이 사용하려면 config.js에 FAL API 키를 넣어 주세요. 또는 node server.js를 실행하세요.'));
            console.log('🟡 [진행 단계] FAL API MO→PC 확장 중...');
            var prompt = 'Same exact image, same scene, same colors, same mood. Only recompose for horizontal layout: place the main content on the FAR RIGHT 40% of the frame. The LEFT 60% must be empty or same background for text. Landscape 16:9. Do not add or remove any object. No new person.';
            var body = { image_url: moImageUrl, prompt: prompt, strength: 0.42 };
            if (seed != null) body.seed = seed;
            var url = useDirect ? 'https://fal.run/fal-ai/flux/dev/image-to-image' : (API_BASE + '/api/fal/image-to-image');
            var opts = useDirect ? { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': 'Key ' + falKey }, body: JSON.stringify(body) } : { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) };
            var responseObj = null;
            return fetch(url, opts)
                .then(function(r) {
                    responseObj = r;
                    if (!r.ok) {
                        return r.json().then(function(errorData) {
                            throw { response: r, errorData: errorData };
                        }).catch(function() {
                            throw { response: r, errorData: { error: { message: 'Unknown error' } } };
                        });
                    }
                    console.log('✅ [진행 단계] FAL API MO→PC 확장 응답 수신 완료');
                    return r.json();
                })
                .then(function(data) {
                    console.log('🟡 [진행 단계] MO→PC 확장 응답 데이터 파싱 중...');
                    var url = (data && data.images && data.images[0] && data.images[0].url) ? data.images[0].url : null;
                    if (!url) throw new Error('fal.ai MO→PC URL 없음');
                    console.log('✅ [진행 단계] FAL MO→PC 확장 완료');
                    return url;
                })
                .catch(function(err) {
                    console.error('❌ FAL API MO→PC 확장 실패');
                    
                    // 상세 에러 정보 출력
                    var sanitizedError = sanitizeErrorForLogging(err);
                    if (sanitizedError) {
                        console.error('📝 에러 메시지:', sanitizedError.message);
                        if (sanitizedError.response) {
                            console.error('📊 HTTP 상태 코드:', sanitizedError.response.status, '(' + sanitizedError.response.statusText + ')');
                            console.error('📋 상태 코드 설명:', getHttpStatusDescription(sanitizedError.response.status));
                            if (sanitizedError.response.data) {
                                console.error('📄 응답 데이터:', sanitizedError.response.data);
                            }
                        }
                    }
                    
                    if (responseObj) {
                        console.error('📊 HTTP 상태 코드:', responseObj.status, '(' + responseObj.statusText + ')');
                        console.error('📋 상태 코드 설명:', getHttpStatusDescription(responseObj.status));
                    }
                    
                    if (err && err.errorData) {
                        var safeErrorData = JSON.stringify(err.errorData).replace(/AIzaSy[A-Za-z0-9_-]+/g, function(match) { return maskApiKey(match); });
                        safeErrorData = safeErrorData.replace(/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}:[a-f0-9]+/gi, function(match) { return maskApiKey(match); });
                        try {
                            console.error('📄 응답 데이터 (API 키 마스킹됨):', JSON.parse(safeErrorData));
                        } catch (e) {
                            console.error('📄 응답 데이터:', safeErrorData);
                        }
                    }
                    
                    try {
                        var errorObj = {
                            name: err.name || 'Error',
                            message: sanitizedError ? sanitizedError.message : (err.message || String(err)),
                            response: sanitizedError ? sanitizedError.response : (err.response || null),
                            errorData: err.errorData || null
                        };
                        console.error('📦 전체 에러 객체 (API 키 마스킹됨):', errorObj);
                    } catch (e) {
                        console.error('⚠️ 에러 객체 직렬화 실패');
                    }
                    
                    return '';
                });
        }
        
        // CSV 파싱 함수
        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const rows = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // CSV 파싱 (쉼표로 구분, 따옴표 처리)
                const values = [];
                let currentValue = '';
                let inQuotes = false;
                
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(currentValue.trim());
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                values.push(currentValue.trim());
                
                rows.push(values);
            }
            
            return rows;
        }
        
        // G열 검색량 문자열을 정렬용 숫자로 변환 (예: "검색 200+회"→200, "검색 1만+회"→10000)
        function parseCountForSort(countStr) {
            if (!countStr || typeof countStr !== 'string') return 0;
            const s = countStr.trim();
            if (s.toLowerCase().includes('search count')) return 0;
            const man = s.match(/(\d+)\s*만/);
            if (man) return (parseInt(man[1], 10) || 0) * 10000;
            const chun = s.match(/(\d+)\s*천/);
            if (chun) return (parseInt(chun[1], 10) || 0) * 1000;
            const num = s.match(/(\d+)/);
            return num ? parseInt(num[1], 10) || 0 : 0;
        }
        
        // 검색량 포맷팅 함수
        function formatSearchCount(count) {
            const num = parseInt(count);
            if (isNaN(num)) return count;
            
            if (num >= 100000) {
                return Math.floor(num / 10000) + '만+';
            } else if (num >= 10000) {
                return Math.floor(num / 1000) + '천+';
            } else if (num >= 1000) {
                return Math.floor(num / 1000) + '천+';
            }
            return num.toString();
        }
        
        // 트렌드 데이터를 가져와서 UI에 표시하는 함수
        async function fetchTrends() {
            // 원본 Google Sheets CSV URL (Trending Searches 시트, 캐시 방지를 위해 타임스탬프 추가)
            const originalUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSWv_8Md3vx8TZezAFvPUQuGJR2cKZZ-PcEelMqGqBhnSTyuXtQi54Kw2dauVa6t-4ZOul_7TiRPz_v/pub?gid=15033788&single=true&output=csv&t=' + Date.now();
            const trendsListContainer = document.getElementById('trendsList');
            const trendsUpdateTime = document.getElementById('trendsUpdateTime');
            
            // 프록시 URL 목록 (폴백 순서)
            const proxyUrls = [
                'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(originalUrl),
                'https://api.allorigins.win/raw?url=' + encodeURIComponent(originalUrl)
            ];
            
            let csvText = null;
            let lastError = null;
            
            try {
                // 로딩 표시
                trendsListContainer.innerHTML = '<div class="p-2 text-sm text-gray-500">로딩 중...</div>';
                
                // 프록시를 통한 데이터 가져오기 시도
                for (let i = 0; i < proxyUrls.length; i++) {
                    try {
                        const response = await fetch(proxyUrls[i], {
                            mode: 'cors',
                            cache: 'no-store'
                        });
                        
                        if (response.ok) {
                            csvText = await response.text();
                            break;
                        } else {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                    } catch (error) {
                        lastError = error;
                        continue;
                    }
                }
                
                // 프록시가 모두 실패하면 직접 fetch 시도
                if (!csvText) {
                    try {
                        const response = await fetch(originalUrl, {
                            mode: 'cors',
                            cache: 'no-store'
                        });
                        
                        if (response.ok) {
                            csvText = await response.text();
                        } else {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                    } catch (error) {
                        lastError = error;
                    }
                }
                
                // 모든 방법이 실패한 경우
                if (!csvText) {
                    throw lastError || new Error('모든 데이터 로드 방법이 실패했습니다.');
                }
                
                // 응답 형식 확인 및 예외 처리 강화
                if (!csvText) {
                    throw new Error('CSV 응답이 null입니다.');
                }
                
                // BOM 제거 (일부 내보내기/엑셀에서 붙는 경우)
                csvText = csvText.replace(/^\uFEFF/, '');
                const trimmedText = csvText.trim();
                if (trimmedText === '' || trimmedText.length === 0) {
                    throw new Error('CSV 데이터가 비어있습니다.');
                }
                
                // CSV를 행으로 나누기
                const lines = csvText.split('\n');
                const rows = [];
                
                // 각 행을 쉼표로 구분하여 배열로 변환
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    // CSV 파싱 (쉼표로 구분, 따옴표 처리)
                    const values = [];
                    let currentValue = '';
                    let inQuotes = false;
                    
                    for (let j = 0; j < line.length; j++) {
                        const char = line[j];
                        
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            values.push(currentValue.trim());
                            currentValue = '';
                        } else {
                            currentValue += char;
                        }
                    }
                    values.push(currentValue.trim());
                    
                    rows.push(values);
                }
                
                // 시트 구조: 1행=헤더, A열(0)=시간, F열(5)=검색어, G열(6)=검색량 (고정)
                const dataStartIndex = 1;
                const timeCol = 0;
                const keywordCol = 5;
                const countCol = 6;
                
                // 기준 시간: 마지막 데이터 행의 A열 값
                let targetTime = null;
                for (let i = rows.length - 1; i >= dataStartIndex; i--) {
                    const row = rows[i];
                    if (row && row.length > timeCol && row[timeCol] != null && String(row[timeCol]).trim() !== '') {
                        targetTime = String(row[timeCol]).trim();
                        break;
                    }
                }
                
                if (!targetTime) {
                    throw new Error('최신 시간대를 찾을 수 없습니다.');
                }
                
                // 동일 시간대 행만 추출 (1행은 헤더 제외)
                const latestRows = [];
                for (let i = dataStartIndex; i < rows.length; i++) {
                    const row = rows[i];
                    if (row && row.length > countCol) {
                        const timeValue = String(row[timeCol] ?? '').trim();
                        if (timeValue === targetTime) latestRows.push(row);
                    }
                }
                
                // 시간대 일치 행이 없으면 전체 데이터 행 사용
                let rowsToUse = latestRows.length > 0 ? latestRows : rows.slice(dataStartIndex);
                
                trendsUpdateTime.textContent = `트렌드 (${targetTime} 업데이트됨)`;
                trendsListContainer.innerHTML = '';
                
                if (rowsToUse.length === 0) {
                    trendsListContainer.innerHTML = '<div class="p-2 text-sm text-gray-500">해당 시간대의 데이터가 없습니다.</div>';
                    currentTrendKeywords = [];
                    updateInsight();
                    return;
                }
                
                // F열=검색어, G열=검색량 — G열은 그대로 표시, 정렬용 숫자만 파싱
                const keywordRows = [];
                rowsToUse.forEach((row) => {
                    const keyword = (row[keywordCol] != null ? String(row[keywordCol]) : '').trim();
                    if (!keyword) return;
                    if (keyword.toLowerCase().includes('search term')) return;
                    const countDisplay = (row[countCol] != null ? String(row[countCol]) : '').trim();
                    const sortNum = parseCountForSort(countDisplay);
                    keywordRows.push({ keyword, countDisplay: countDisplay || '-', searchCount: sortNum });
                });
                keywordRows.sort((a, b) => b.searchCount - a.searchCount);
                currentTrendKeywords = keywordRows;
                
                // 리스트 UI 생성 (검색량은 G열 값 그대로 표시)
                keywordRows.forEach(({ keyword, countDisplay }) => {
                    const listItem = document.createElement('div');
                    listItem.className = 'p-2 rounded cursor-pointer hover:bg-gray-50 flex justify-between items-center trend-item';
                    listItem.dataset.keyword = keyword;
                    
                    listItem.addEventListener('click', function() {
                        document.querySelectorAll('.trend-item').forEach(item => {
                            item.classList.remove('border-2', 'border-indigo-500', 'bg-indigo-50');
                            const keywordSpan = item.querySelector('.keyword-text');
                            const countDiv = item.querySelector('.count-text');
                            if (keywordSpan) keywordSpan.classList.remove('font-bold', 'text-indigo-600');
                            if (countDiv) countDiv.classList.remove('text-indigo-600');
                        });
                        this.classList.add('border-2', 'border-indigo-500', 'bg-indigo-50');
                        const keywordSpan = this.querySelector('.keyword-text');
                        const countDiv = this.querySelector('.count-text');
                        if (keywordSpan) keywordSpan.classList.add('font-bold', 'text-indigo-600');
                        if (countDiv) countDiv.classList.add('text-indigo-600');
                        selectedKeyword = keyword;
                        updateInsight();
                    });
                    
                    listItem.innerHTML = `
                        <span class="text-sm text-gray-700 keyword-text">${keyword}</span>
                        <div class="text-right">
                            <div class="text-sm font-bold count-text">${countDisplay || '-'}</div>
                            <div class="text-xs text-red-500">↑ ${Math.floor(Math.random() * 900 + 100)}%</div>
                        </div>
                    `;
                    trendsListContainer.appendChild(listItem);
                });
                
                // 키워드 로드 직후 AI MD 제안 먼저 표시
                updateInsight();
                
            } catch (error) {
                // 에러 메시지에서 API 키 마스킹
                var safeErrorMsg = error.message || String(error);
                safeErrorMsg = maskApiKeyInUrl(safeErrorMsg);
                safeErrorMsg = safeErrorMsg.replace(/AIzaSy[A-Za-z0-9_-]+/g, function(match) { return maskApiKey(match); });
                safeErrorMsg = safeErrorMsg.replace(/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}:[a-f0-9]+/gi, function(match) { return maskApiKey(match); });
                
                console.error('❌ 트렌드 데이터를 가져오는 중 오류 발생:', safeErrorMsg);
                
                // 더 자세한 에러 메시지 표시
                var errorMsg = '데이터를 불러올 수 없습니다.';
                if (error.message && error.message.includes('CORS')) {
                    errorMsg = 'CORS 오류: Google Sheets 접근이 차단되었습니다.';
                } else if (error.message && error.message.includes('HTTP error')) {
                    errorMsg = 'HTTP 오류: 서버 응답을 받을 수 없습니다.';
                } else if (error.message && error.message.includes('비어있습니다')) {
                    errorMsg = 'CSV 데이터가 비어있습니다. Google Sheets를 확인해주세요.';
                }
                
                trendsListContainer.innerHTML = '<div class="p-2 text-sm text-red-500">' + errorMsg + '</div>';
                trendsUpdateTime.textContent = '트렌드 (오류 발생)';
                
                // currentTrendKeywords 초기화
                currentTrendKeywords = [];
                updateInsight();
            }
        }
        
        // AI MD 제안 문구 실시간 업데이트 (키워드 로드 후 먼저 제안, 선택 시 구체화)
        function updateInsight() {
            const el = document.getElementById('aiInsightText');
            if (!el) return;
            
            const topN = currentTrendKeywords.slice(0, 5);
            const topKeywords = topN.map(k => k.keyword);
            const topKeywordStr = topKeywords.length ? topKeywords.join(', ') : '';
            
            if (selectedKeyword) {
                // 사용자가 키워드를 선택한 경우 — 해당 키워드 기준 구체적 제안
                const keyword = selectedKeyword;
                const item = currentTrendKeywords.find(k => k.keyword === keyword);
                const vol = item && item.countDisplay ? item.countDisplay : (item ? formatSearchCount(String(item.searchCount)) : '');
                if (selectedBrand === 'DV') {
                    el.textContent = `[선택 키워드: ${keyword}${vol ? ' · 검색량 ' + vol : ''}]\n\n` +
                        `이 키워드를 메인으로 한 감성 룩북 기획을 추천합니다. 헤드라인에는 트렌드 감성(“${keyword}”)을 녹이고, 서브카피에서는 시즌 무드나 착용 포인트를 짧게 강조하세요. ` +
                        `템플릿 A(배너형) 또는 C(리스트형)로 키워드 노출을 크게 하면 검색 유입에 유리합니다. 참조 이미지는 해당 키워드와 맞는 한 벌 코디나 무드 사진을 넣어 주세요.`;
                } else {
                    el.textContent = `[선택 키워드: ${keyword}${vol ? ' · 검색량 ' + vol : ''}]\n\n` +
                        `"${keyword}" 검색량이 높은 만큼, 타임세일·한정수량·즉시 할인 등 유니크 세일 포인트를 앞에 두는 전략을 추천합니다. ` +
                        `템플릿 B(카드형)나 D(이벤트형)로 가격/혜택을 강조하고, 기획 의도에는 “한정 기간”, “선착 N명” 등을 명시하면 전환에 도움이 됩니다.`;
                }
                return;
            }
            
            if (topN.length === 0) {
                el.textContent = '트렌드 키워드를 불러오는 중입니다. 로드 후 자동으로 제안이 표시됩니다.';
                return;
            }
            
            // 키워드만 로드된 상태 — 사용자 선택 전, 상위 키워드 기반으로 먼저 제안
            if (selectedBrand === 'DV') {
                el.textContent = `[현재 트렌드 상위 키워드: ${topKeywordStr}]\n\n` +
                    `위 키워드를 반영한 감성 룩북 기획을 추천합니다. 검색량이 높은 순으로 1~2개를 메인 키워드로 정하고, 헤드라인·서브카피에 자연스럽게 녹여 주세요. ` +
                    `키워드 강조가 목표라면 템플릿 A(배너형) 또는 C(리스트형), 무드 중심이라면 B(카드형)를 권장합니다. 왼쪽 목록에서 원하는 검색어를 클릭하면 해당 키워드 기준으로 더 구체적인 제안을 드립니다.`;
            } else {
                el.textContent = `[현재 트렌드 상위 키워드: ${topKeywordStr}]\n\n` +
                    `이 키워드들의 검색 수요를 활용해 타임세일·한정 혜택 중심 기획을 추천합니다. 상위 1~2개를 메인으로 잡고, 가격/할인/선착순을 강조하는 문구를 넣어 주세요. ` +
                    `템플릿 B(카드형) 또는 D(이벤트형)로 세일즈 포인트를 크게 노출하고, 기획 의도에 “한정 기간”, “선착 N명” 등을 적어 두시면 좋습니다. 왼쪽에서 키워드를 선택하면 해당 검색어 기준 맞춤 제안을 드립니다.`;
            }
        }

        // 브랜드 선택 이벤트 리스너 설정
        function setupBrandSelection() {
            const brandRadios = document.querySelectorAll('input[name="brand"]');
            const checkedRadio = document.querySelector('input[name="brand"]:checked');
            if (checkedRadio) {
                selectedBrand = checkedRadio.value;
            }
            
            brandRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    selectedBrand = this.value;
                    updateInsight();
                });
            });
        }
        
        // 템플릿 카드 선택 및 PC/MO 토글 설정
        function setupTemplateSelection() {
            const cards = document.querySelectorAll('.template-card');
            cards.forEach(card => {
                card.addEventListener('click', function() {
                    if (this.classList.contains('template-card--preparing') || this.dataset.template !== 'A') return;
                    const template = this.dataset.template;
                    selectedTemplate = template;

                    // 모든 카드에서 선택 스타일 제거
                    cards.forEach(c => {
                        c.classList.remove('ring-4', 'ring-indigo-500', 'ring-offset-2');
                        c.querySelector('.template-check').classList.add('hidden');
                    });
                    document.querySelectorAll('.template-variant').forEach(btn => {
                        btn.classList.remove('bg-indigo-600', 'text-white', 'font-medium');
                        btn.classList.add('text-gray-500');
                    });

                    // 선택한 카드에 ring + 체크 아이콘 표시
                    this.classList.add('ring-4', 'ring-indigo-500', 'ring-offset-2');
                    this.querySelector('.template-check').classList.remove('hidden');

                    // 선택한 카드 내 PC/MO 버튼 중 현재 selectedVariant 활성화
                    this.querySelectorAll('.template-variant').forEach(btn => {
                        if (btn.dataset.variant === selectedVariant) {
                            btn.classList.add('bg-indigo-600', 'text-white', 'font-medium');
                            btn.classList.remove('text-gray-500');
                        } else {
                            btn.classList.remove('bg-indigo-600', 'text-white', 'font-medium');
                            btn.classList.add('text-gray-500');
                        }
                    });
                });
            });

            // PC/MO 버튼 클릭 (카드 내부 토글)
            document.querySelectorAll('.template-variant').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const template = this.dataset.template;
                    const variant = this.dataset.variant;
                    if (template !== selectedTemplate) return;
                    selectedVariant = variant;

                    document.querySelectorAll('.template-variant').forEach(b => {
                        b.classList.remove('bg-indigo-600', 'text-white', 'font-medium');
                        b.classList.add('text-gray-500');
                    });
                    document.querySelectorAll('.template-variant[data-template="' + template + '"]').forEach(b => {
                        if (b.dataset.variant === variant) {
                            b.classList.add('bg-indigo-600', 'text-white', 'font-medium');
                            b.classList.remove('text-gray-500');
                        }
                    });
                });
            });

            // 초기 상태: A 카드 선택 + PC 활성화
            const firstCard = document.querySelector('.template-card[data-template="A"]');
            if (firstCard) {
                firstCard.classList.add('ring-4', 'ring-indigo-500', 'ring-offset-2');
                firstCard.querySelector('.template-check').classList.remove('hidden');
                firstCard.querySelector('.template-variant[data-variant="PC"]').classList.add('bg-indigo-600', 'text-white', 'font-medium');
                firstCard.querySelector('.template-variant[data-variant="PC"]').classList.remove('text-gray-500');
            }
        }
        
        // 초기화 함수: 모든 상태를 리셋하고 처음부터 다시 시작할 수 있도록
        function resetAll() {
            // 상태 변수 리셋
            selectedKeyword = null;
            selectedBrand = 'DV';
            selectedTemplate = 'A';
            referenceImageFromFile = null;
            referenceImageUrlFromInput = null;
            updateReferenceImage();
            var urlInp = document.getElementById('referenceImageUrlInput');
            if (urlInp) urlInp.value = '';
            selectedAiMode = null;
            
            // UI 리셋
            // 1. 키워드 선택 해제
            document.querySelectorAll('.trend-item').forEach(function(item) {
                item.classList.remove('bg-indigo-100', 'border-indigo-400', 'ring-2', 'ring-indigo-300');
            });
            
            // 2. 브랜드 선택 리셋 (DV로)
            document.querySelectorAll('.brand-btn').forEach(function(btn) {
                btn.classList.remove('bg-indigo-600', 'text-white');
                btn.classList.add('bg-white', 'text-gray-700', 'border-gray-300');
            });
            var dvBtn = document.querySelector('.brand-btn[data-brand="DV"]');
            if (dvBtn) {
                dvBtn.classList.remove('bg-white', 'text-gray-700', 'border-gray-300');
                dvBtn.classList.add('bg-indigo-600', 'text-white');
            }
            
            // 3. 템플릿 선택 리셋 (A로)
            document.querySelectorAll('.template-card').forEach(function(card) {
                card.classList.remove('ring-4', 'ring-indigo-500', 'ring-offset-2');
            });
            var templateA = document.querySelector('.template-card[data-template="A"]');
            if (templateA) {
                templateA.classList.add('ring-4', 'ring-indigo-500', 'ring-offset-2');
            }
            
            // 4. 참조 이미지 초기화
            var referenceInput = document.getElementById('referenceImageInput');
            if (referenceInput) referenceInput.value = '';
            var referenceLabel = document.getElementById('referenceImageLabel');
            if (referenceLabel) referenceLabel.textContent = '제품 이미지를 올리면 키워드와 기획의도에 맞는 배경에 합성합니다';
            var referenceZone = document.getElementById('referenceImageZone');
            if (referenceZone) {
                referenceZone.classList.remove('border-indigo-300', 'bg-indigo-50/30');
            }
            
            // 5. AI 생성 모드 리셋
            document.querySelectorAll('input[name="aiGenerateMode"]').forEach(function(radio) {
                radio.checked = false;
            });
            
            // 6. 기획 의도 텍스트 초기화
            var campaignIntent = document.getElementById('campaignIntent');
            if (campaignIntent) campaignIntent.value = '';
            
            // 7. 생성 상태 메시지 초기화
            setGenerateStatus('');
            
            // 8. 생성된 이미지 숨기기 및 리셋
            var moImg = document.getElementById('resultMoImage');
            var pcImg = document.getElementById('resultPcImage');
            if (moImg) {
                moImg.src = '';
                moImg.classList.add('hidden');
            }
            if (pcImg) {
                pcImg.src = '';
            }
            
            // 9. 플레이스홀더 다시 표시
            var moPh = document.getElementById('resultMoPlaceholder');
            var pcPh = document.getElementById('resultPcPlaceholder');
            if (moPh) {
                moPh.textContent = '키워드 선택 후 AI 시안 생성하기를 누르세요.';
                moPh.classList.remove('hidden');
            }
            if (pcPh) {
                pcPh.textContent = '키워드 선택 후 AI 시안 생성하기를 누르세요.';
                pcPh.classList.remove('hidden');
            }
            
            // 10. 텍스트 오버레이 숨기기
            var moOverlay = document.getElementById('resultMoOverlay');
            var pcOverlay = document.getElementById('resultPcOverlay');
            if (moOverlay) moOverlay.classList.add('hidden');
            if (pcOverlay) pcOverlay.classList.add('hidden');
            
            // 11. 브랜드/키워드 텍스트 초기화
            var moBrand = document.getElementById('resultMoBrand');
            var moKeyword = document.getElementById('resultMoKeyword');
            var pcBrand = document.getElementById('resultPcBrand');
            var pcKeyword = document.getElementById('resultPcKeyword');
            if (moBrand) moBrand.textContent = '';
            if (moKeyword) moKeyword.textContent = '';
            if (pcBrand) pcBrand.textContent = '';
            if (pcKeyword) pcKeyword.textContent = '';
            
            // 12. 결과 섹션으로 스크롤 (선택사항)
            var resultSection = document.getElementById('result');
            if (resultSection) {
                resultSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            
            alert('모든 설정이 초기화되었습니다. 검색어 선택부터 다시 시작하세요.');
        }
        
        // AI 시안 생성 버튼 클릭 이벤트 (Gemini → 카피 반영 → 이미지 URL → textStyle 배치)
        function setupGenerateButton() {
            var generateButton = document.getElementById('generateButton');
            var resetButton = document.getElementById('resetButton');
            
            // 초기화 버튼 이벤트
            if (resetButton) {
                resetButton.addEventListener('click', function() {
                    resetAll();
                });
            }
            
            generateButton.addEventListener('click', async function() {
                var campaignIntent = document.getElementById('campaignIntent').value;
                if (!selectedKeyword || !selectedTemplate) {
                    alert('키워드와 템플릿을 선택해주세요.');
                    return;
                }
                var modeRadios = document.querySelectorAll('input[name="aiGenerateMode"]');
                var aiMode = null;
                modeRadios.forEach(function(r) { if (r.checked) aiMode = r.value; });
                selectedAiMode = aiMode;
                
                // API 선택 확인
                var apiRadios = document.querySelectorAll('input[name="imageApi"]');
                var imageApi = 'fal';
                apiRadios.forEach(function(r) { if (r.checked) imageApi = r.value; });
                selectedImageApi = imageApi;
                console.log('🔵 [API 선택]', imageApi === 'replicate' ? 'Replicate API 사용' : 'FAL API 사용');
                
                var btn = this;
                var origText = btn.textContent;
                btn.disabled = true;
                // URL 입력란 값 생성 직전에 한 번 더 반영 (참조 이미지 확실히 적용)
                var urlInputSync = document.getElementById('referenceImageUrlInput');
                if (urlInputSync) {
                    var v = (urlInputSync.value || '').trim();
                    if (v) {
                        if (!/^https?:\/\//i.test(v)) v = 'https://' + v;
                        if (/^https?:\/\/.+/i.test(v)) {
                            referenceImageUrlFromInput = v;
                            updateReferenceImage();
                        }
                    }
                }
                console.log('🟡 [참조 이미지] 사용 여부:', hasReferenceImage, '| URL:', referenceImageUrl ? (referenceImageUrl.length > 60 ? referenceImageUrl.substring(0, 60) + '...' : referenceImageUrl) : '(없음)');
                setGenerateStatus('프롬프트 구성 중...');
                var geminiResult = await getPromptResult(selectedBrand, selectedKeyword, campaignIntent, aiMode, hasReferenceImage);
                var brandCopy = (geminiResult.brandCopy || '').trim() || selectedBrand + ' 26SS 컬렉션';
                var keywordCopy = (geminiResult.keywordCopy || '').trim() || selectedKeyword;
                document.getElementById('resultMoBrand').textContent = brandCopy;
                document.getElementById('resultMoKeyword').textContent = keywordCopy;
                document.getElementById('resultPcBrand').textContent = brandCopy;
                document.getElementById('resultPcKeyword').textContent = keywordCopy;
                var editBrandEl = document.getElementById('editBrand');
                var editKeywordEl = document.getElementById('editKeyword');
                if (editBrandEl) editBrandEl.value = brandCopy;
                if (editKeywordEl) editKeywordEl.value = keywordCopy;
                setGenerateStatus('AI 디자이너가 고화질 시안을 그리고 있습니다...');
                overlayInited['mo-brand'] = overlayInited['mo-keyword'] = overlayInited['pc-brand'] = overlayInited['pc-keyword'] = false;
                var moPhReset = document.getElementById('resultMoPlaceholder');
                if (moPhReset) moPhReset.textContent = '키워드 선택 후 AI 시안 생성하기를 누르세요.';
                var loadingEl = document.getElementById('imageLoadingOverlay');
                var loadingMsgEl = document.getElementById('imageLoadingOverlayMessage');
                if (loadingMsgEl) loadingMsgEl.textContent = 'MO·PC 시안 동시 생성 중...';
                if (loadingEl) { loadingEl.classList.add('visible'); loadingEl.setAttribute('aria-hidden', 'false'); }
                var pcImageSrc, moImageSrc;
                try {
                    console.log('🟡 [진행 단계] 이미지 생성 시작 (MO·PC 동시 생성)');
                    var baseSeed = Math.floor(Math.random() * 1000000);
                    lastImageSeed = baseSeed;
                    console.log('🟡 [진행 단계] 시드 생성 완료:', baseSeed);
                    
                    // 선택된 API에 따라 다른 함수 호출
                    // 주의: Replicate API는 CORS 문제로 브라우저에서 직접 호출 불가
                    // 서버 사이드 프록시가 필요하므로 현재는 FAL API만 사용
                    var promMo, promPc;
                    if (selectedImageApi === 'replicate') {
                        console.log('🟡 [진행 단계] Replicate API 호출 중 (한도 방지를 위해 MO → PC 순차 생성)...');
                        moImageSrc = await fetchReplicateImage(selectedBrand, geminiResult.imagePromptMo || geminiResult.imagePrompt, baseSeed, true, referenceImageUrl);
                        pcImageSrc = await fetchReplicateImage(selectedBrand, geminiResult.imagePrompt, baseSeed, false, referenceImageUrl);
                        if (!pcImageSrc && moImageSrc) pcImageSrc = moImageSrc;
                        console.log('🟡 [진행 단계] Replicate API 호출 완료.');
                    } else {
                        promMo = fetchNanoBananaImage(selectedBrand, geminiResult.imagePromptMo || geminiResult.imagePrompt, baseSeed, true, referenceImageUrl);
                        promPc = fetchNanoBananaImage(selectedBrand, geminiResult.imagePrompt, baseSeed, false, referenceImageUrl);
                        console.log('🟡 [진행 단계] FAL API 호출 완료, 응답 대기 중...');
                        var results = await Promise.all([promMo, promPc]);
                        moImageSrc = results[0] || '';
                        pcImageSrc = results[1] || '';
                        if (!pcImageSrc && moImageSrc) pcImageSrc = moImageSrc;
                    }
                    console.log('✅ [진행 단계] 이미지 생성 완료 (MO:', !!moImageSrc, 'PC:', !!pcImageSrc, ')');
                } catch (error) {
                    console.error('❌ 이미지 생성 중 오류 발생');
                    var sanitizedError = sanitizeErrorForLogging(error);
                    if (sanitizedError) {
                        console.error('📝 에러 메시지:', sanitizedError.message);
                        if (sanitizedError.stack) {
                            console.error('🔍 에러 스택:', sanitizedError.stack);
                        }
                    }
                    setGenerateStatus('');
                    btn.disabled = false;
                    btn.textContent = origText;
                    var errMsg = (sanitizedError && sanitizedError.message) ? sanitizedError.message : (error && error.message) ? error.message : '알 수 없는 오류';
                    var status429 = (error && error.response && error.response.status === 429);
                    if (status429) {
                        alert('요청 한도를 초과했습니다 (429 Too Many Requests).\n\nReplicate에서 한도가 걸린 상태입니다. 보통 약 30초 후에 풀립니다.\n• 30초~1분 기다린 뒤 다시 시도해 주세요.\n• 사용량/결제 확인: https://replicate.com/account/billing');
                    } else if (selectedImageApi === 'replicate') {
                        alert('키워드 반영 이미지 생성에 실패했습니다.\n\nReplicate API 오류일 수 있습니다. 확인할 것:\n• server.js 터미널에 에러 로그가 있는지\n• Replicate API 키가 유효한지\n• Replicate 서비스 상태\n\n콘솔(F12)에서 상세 오류를 확인할 수 있습니다.');
                    } else {
                        alert('키워드 반영 이미지 생성에 실패했습니다.\n\nFAL API 키를 확인하거나, 잠시 후 다시 시도해 주세요.\n\n오류: ' + errMsg);
                    }
                    return;
                } finally {
                    if (loadingEl) { loadingEl.classList.remove('visible'); loadingEl.setAttribute('aria-hidden', 'true'); }
                }
                var moImg = document.getElementById('resultMoImage');
                var pcImg = document.getElementById('resultPcImage');
                var moPh = document.getElementById('resultMoPlaceholder');
                var pcPh = document.getElementById('resultPcPlaceholder');
                var moOverlay = document.getElementById('resultMoOverlay');
                var pcOverlay = document.getElementById('resultPcOverlay');
                function showMo() {
                    moImg.classList.remove('hidden');
                    moPh.classList.add('hidden');
                    moOverlay.classList.remove('hidden');
                    setTimeout(function() { initOverlayPositions(); }, 50);
                }
                function showPc() {
                    pcImg.classList.remove('hidden');
                    pcPh.classList.add('hidden');
                    pcOverlay.classList.remove('hidden');
                    setTimeout(function() { initOverlayPositions(); }, 50);
                }
                function hideMo() {
                    moImg.classList.add('hidden');
                    moPh.classList.remove('hidden');
                    moOverlay.classList.add('hidden');
                }
                function hidePc() {
                    pcImg.classList.add('hidden');
                    pcPh.classList.remove('hidden');
                    pcOverlay.classList.add('hidden');
                }
                pcImg.crossOrigin = 'anonymous';
                // 모바일 이미지 태그 존재 및 상태 확인 (디버깅용 로그 제거)
                
                // 모바일 이미지 생성 즉시 표시: src 할당 후 UI 즉시 전환(로드는 onload에서 완료)
                function forceShowMo() {
                    if (!moImageSrc) { console.error('MO 이미지 소스가 없습니다!'); return; }
                    var el = document.getElementById('resultMoImage');
                    if (!el || !el.parentNode) { console.error('resultMoImage 요소가 DOM에 없습니다.'); return; }
                    lastGeneratedMoImageUrl = moImageSrc;
                    el.removeAttribute('crossorigin');
                    el.crossOrigin = '';
                    el.src = moImageSrc;
                    el.setAttribute('style', 'display: block !important; visibility: visible !important;');
                    el.style.setProperty('display', 'block', 'important');
                    el.style.setProperty('visibility', 'visible', 'important');
                    el.classList.remove('hidden');
                    if (moPh) moPh.classList.add('hidden');
                    if (moOverlay) moOverlay.classList.remove('hidden');
                    requestAnimationFrame(function() {
                        el.setAttribute('style', 'display: block !important; visibility: visible !important;');
                        el.classList.remove('hidden');
                    });
                    setTimeout(function() { initOverlayPositions(); }, 50);
                }
                
                moImg.onload = function() { 
                    lastGeneratedMoImageUrl = moImageSrc;
                    moImg.classList.remove('hidden');
                    showMo(); 
                };
                moImg.onerror = function() { 
                    // MO 영역은 숨기지 않고, placeholder만 보이도록 (모바일 시안 칸은 항상 유지)
                    moImg.classList.add('hidden');
                    if (moPh) moPh.classList.remove('hidden');
                    if (moPh) moPh.textContent = 'MO 이미지를 불러올 수 없습니다.';
                    if (moOverlay) moOverlay.classList.add('hidden');
                };
                pcImg.onload = function() { 
                    showPc(); 
                };
                pcImg.onerror = function() { 
                    hidePc(); 
                };
                
                // PC 이미지 즉시 할당 및 강제 노출
                if (pcImageSrc) {
                    pcImg.src = pcImageSrc;
                    pcImg.style.setProperty('display', 'block', 'important');
                    pcImg.classList.remove('hidden');
                    if (pcPh) pcPh.classList.add('hidden');
                    if (pcOverlay) pcOverlay.classList.remove('hidden');
                }
                if (pcImg.complete && pcImageSrc) {
                    setTimeout(function() { if (pcImg.src === pcImageSrc) showPc(); }, 100);
                }
                
                // MO: moImageSrc 생성되자마자 resultMoImage.src 할당, display/hidden !important 강제
                if (moImageSrc) {
                    if (moImg) {
                        moImg.src = moImageSrc;
                        moImg.style.setProperty('display', 'block', 'important');
                        moImg.style.setProperty('visibility', 'visible', 'important');
                        moImg.classList.remove('hidden');
                        if (moPh) moPh.classList.add('hidden');
                        if (moOverlay) moOverlay.classList.remove('hidden');
                    }
                    forceShowMo();
                }
                
                lastGeneratedImageUrl = pcImageSrc;
                lastGeneratedPcImageUrl = pcImageSrc;
                lastImagePrompt = geminiResult.imagePrompt;
                lastDetailInstructions = campaignIntent || '';
                lastAiMode = aiMode;
                
                setGenerateStatus('');
                btn.disabled = false;
                btn.textContent = origText;
                var resultEl = document.getElementById('result');
                requestAnimationFrame(function() {
                    var y = resultEl.getBoundingClientRect().top + window.pageYOffset - 16;
                    window.scrollTo({ top: y, behavior: 'smooth' });
                });
            });
        }
        
        // 시안 다운로드: 파일명에 쓸 수 없는 문자 제거
        function sanitizeFilename(str) {
            return String(str).replace(/[/\\:*?"<>|\s]+/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '') || '시안';
        }
        
        // 이미지 URL → Base64 (CORS 허용 필요)
        function imageToBase64(imgEl) {
            return new Promise(function(resolve, reject) {
                if (!imgEl || !imgEl.src) { reject(new Error('이미지 없음')); return; }
                if (imgEl.src.startsWith('data:')) { resolve(imgEl.src); return; }
                var img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = function() {
                    try {
                        var c = document.createElement('canvas');
                        c.width = img.naturalWidth || img.width;
                        c.height = img.naturalHeight || img.height;
                        var ctx = c.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        resolve(c.toDataURL('image/png'));
                    } catch (e) { reject(e); }
                };
                img.onerror = function() { reject(new Error('이미지 로드 실패(CORS 등)')); };
                img.src = imgEl.src;
            });
        }
        
        // XML 텍스트 이스케이프
        function escapeXml(s) {
            return String(s)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }
        
        // MO 시안 PNG 저장
        function downloadMoImage() {
            if (!selectedKeyword || !selectedBrand) { alert('먼저 키워드를 선택하고 AI 시안 생성하기를 실행해주세요.'); return; }
            var el = document.getElementById('resultMoCapture');
            if (!el || typeof html2canvas === 'undefined') { alert('다운로드 도구를 불러오는 중입니다. 잠시 후 다시 시도해주세요.'); return; }
            var brand = selectedBrand === 'DV' ? 'DV' : 'ST';
            var name = sanitizeFilename(brand) + '_' + sanitizeFilename(selectedKeyword) + '_MO.png';
            html2canvas(el, { useCORS: true, scale: 2, backgroundColor: null }).then(function(canvas) {
                var a = document.createElement('a');
                a.href = canvas.toDataURL('image/png');
                a.download = name;
                a.click();
            }).catch(function(err) { console.error(err); alert('이미지 저장에 실패했습니다.'); });
        }
        
        // PC 시안 PNG 저장
        function downloadPcImage() {
            if (!selectedKeyword || !selectedBrand) { alert('먼저 키워드를 선택하고 AI 시안 생성하기를 실행해주세요.'); return; }
            var el = document.getElementById('resultPcCapture');
            if (!el || typeof html2canvas === 'undefined') { alert('다운로드 도구를 불러오는 중입니다. 잠시 후 다시 시도해주세요.'); return; }
            var brand = selectedBrand === 'DV' ? 'DV' : 'ST';
            var name = sanitizeFilename(brand) + '_' + sanitizeFilename(selectedKeyword) + '_PC.png';
            html2canvas(el, { useCORS: true, scale: 2, backgroundColor: null }).then(function(canvas) {
                var a = document.createElement('a');
                a.href = canvas.toDataURL('image/png');
                a.download = name;
                a.click();
            }).catch(function(err) { console.error(err); alert('이미지 저장에 실패했습니다.'); });
        }
        
        // MO+PC 압축 다운로드
        function downloadAllImages() {
            if (!selectedKeyword || !selectedBrand) { alert('먼저 키워드를 선택하고 AI 시안 생성하기를 실행해주세요.'); return; }
            if (typeof JSZip === 'undefined' || typeof html2canvas === 'undefined') { alert('다운로드 도구를 불러오는 중입니다. 잠시 후 다시 시도해주세요.'); return; }
            var brand = selectedBrand === 'DV' ? 'DV' : 'ST';
            var base = sanitizeFilename(brand) + '_' + sanitizeFilename(selectedKeyword);
            var zip = new JSZip();
            Promise.all([
                html2canvas(document.getElementById('resultMoCapture'), { useCORS: true, scale: 2, backgroundColor: null }),
                html2canvas(document.getElementById('resultPcCapture'), { useCORS: true, scale: 2, backgroundColor: null })
            ]).then(function(results) {
                zip.file(base + '_MO.png', results[0].toDataURL('image/png').split(',')[1], { base64: true });
                zip.file(base + '_PC.png', results[1].toDataURL('image/png').split(',')[1], { base64: true });
                return zip.generateAsync({ type: 'blob' });
            }).then(function(blob) {
                var a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = base + '_시안.zip';
                a.click();
                URL.revokeObjectURL(a.href);
            }).catch(function(err) { console.error(err); alert('압축 다운로드에 실패했습니다.'); });
        }
        
        // 시안 텍스트 오버레이: 위치·크기 상태 (px). html2canvas 캡처 시 이 값이 그대로 반영됨
        var overlayState = {
            'mo-brand': { x: 0, y: 0, fontSize: 14 },
            'mo-keyword': { x: 0, y: 0, fontSize: 28 },
            'pc-brand': { x: 0, y: 0, fontSize: 16 },
            'pc-keyword': { x: 0, y: 0, fontSize: 36 }
        };
        var overlayInited = { 'mo-brand': false, 'mo-keyword': false, 'pc-brand': false, 'pc-keyword': false };
        
        function getOverlayBox(target) { return document.querySelector('.overlay-text-box[data-target="' + target + '"]'); }
        function getTextSpan(box) { return box ? box.querySelector('span:not(.resize-handle)') : null; }
        function getCaptureFor(target) { return target.indexOf('mo') === 0 ? document.getElementById('resultMoCapture') : document.getElementById('resultPcCapture'); }
        
        // 피그마 SVG 출력 고정: PC 3840x1760, MO 2304x3500 하드코딩. 텍스트 좌표 PC=좌측, MO=상단 고정(제품과 겹치지 않음)
        var FIGMA_MO_WIDTH = 2304, FIGMA_MO_HEIGHT = 3500, FIGMA_PC_WIDTH = 3840, FIGMA_PC_HEIGHT = 1760;
        var SAFE_MO_Y_MAX_RATIO = 0.35;
        var SAFE_PC_X_MAX_RATIO = 0.60;
        async function buildSvgForFigma(variant) {
            var isMo = variant === 'mo';
            var captureId = isMo ? 'resultMoCapture' : 'resultPcCapture';
            var imgId = isMo ? 'resultMoImage' : 'resultPcImage';
            var targets = isMo ? ['mo-brand', 'mo-keyword'] : ['pc-brand', 'pc-keyword'];
            var vbW = isMo ? FIGMA_MO_WIDTH : FIGMA_PC_WIDTH;
            var vbH = isMo ? FIGMA_MO_HEIGHT : FIGMA_PC_HEIGHT;
            console.log('피그마 SVG 생성:', { variant: variant, viewBox: '0 0 ' + vbW + ' ' + vbH });
            var capture = document.getElementById(captureId);
            var imgEl = document.getElementById(imgId);
            if (!capture || !imgEl || !imgEl.src || imgEl.classList.contains('hidden')) {
                alert('먼저 AI 시안을 생성해주세요.');
                return null;
            }
            var base64 = null;
            try {
                base64 = await imageToBase64(imgEl);
            } catch (e) {
                console.error(e);
                alert('이미지를 Base64로 변환할 수 없습니다. CORS가 허용된 이미지인지 확인해주세요.');
                return null;
            }
            var captureRect = capture.getBoundingClientRect();
            var canvasW = captureRect.width;
            var canvasH = captureRect.height;
            var scaleX = vbW / canvasW;
            var scaleY = vbH / canvasH;
            var defsNodes = [];
            var gradientNodes = [];
            var textNodes = [];
            var defaultsMap = getTextStyleDefaults(selectedBrand || 'DV');
            var gradientCounter = 0;
            for (var i = 0; i < targets.length; i++) {
                var target = targets[i];
                var state = overlayState[target];
                var box = getOverlayBox(target);
                var textSpan = getTextSpan(box);
                var text = textSpan ? textSpan.textContent : '';
                if (!state || !box || !textSpan) continue;
                var boxRect = box.getBoundingClientRect();
                var textRect = textSpan.getBoundingClientRect();
                var computedStyle = window.getComputedStyle(textSpan);
                var relativeX = boxRect.left - captureRect.left;
                var relativeY = boxRect.top - captureRect.top;
                var xPercent = (relativeX / canvasW) * 100;
                var yPercent = ((relativeY + textRect.height) / canvasH) * 100;
                var x = Math.round((xPercent / 100) * vbW);
                var y = Math.round((yPercent / 100) * vbH);
                var fontSizePx = parseFloat(computedStyle.fontSize) || state.fontSize;
                var fs = Math.round(fontSizePx * scaleY);
                var fontWeight = computedStyle.fontWeight || 'bold';
                var fillColor = computedStyle.color || 'white';
                var fontFamily = computedStyle.fontFamily || 'sans-serif';
                var d = defaultsMap[target] || {};
                var textAnchor = d.centerHoriz ? 'middle' : (d.leftAlign ? 'start' : 'start');
                if (isMo) {
                    x = Math.round(vbW / 2);
                    var moYRatio = Math.min(d.yRatio !== undefined ? d.yRatio : 0.10, SAFE_MO_Y_MAX_RATIO);
                    y = Math.round(moYRatio * vbH);
                } else {
                    var pcXRatio = Math.min(d.leftMarginRatio !== undefined ? d.leftMarginRatio : 0.10, SAFE_PC_X_MAX_RATIO);
                    var forcedY = (d.yRatio !== undefined ? d.yRatio : 0.40) * vbH;
                    x = Math.round(pcXRatio * vbW);
                    y = Math.round(forcedY);
                }
                var textBoxW = boxRect.width;
                var textBoxH = textRect.height;
                var gradientBoxX = Math.round((relativeX / canvasW) * vbW);
                var gradientBoxY = Math.round((relativeY / canvasH) * vbH);
                var gradientBoxW = Math.round((textBoxW / canvasW) * vbW);
                var gradientBoxH = Math.round((textBoxH / canvasH) * vbH);
                var gradientId = 'gradient-' + gradientCounter++;
                defsNodes.push('<linearGradient id="' + gradientId + '" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:rgba(0,0,0,0.3);stop-opacity:1" /><stop offset="100%" style="stop-color:rgba(0,0,0,0.1);stop-opacity:1" /></linearGradient>');
                gradientNodes.push('<rect x="' + gradientBoxX + '" y="' + gradientBoxY + '" width="' + gradientBoxW + '" height="' + gradientBoxH + '" fill="url(#' + gradientId + ')"/>');
                textNodes.push('<text x="' + x + '" y="' + y + '" font-size="' + fs + '" fill="' + fillColor + '" font-weight="' + escapeXml(fontWeight) + '" font-family="' + escapeXml(fontFamily) + '" text-anchor="' + textAnchor + '">' + escapeXml(text) + '</text>');
            }
            var defsSection = defsNodes.length > 0 ? '<defs>' + defsNodes.join('') + '</defs>' : '';
            // 피그마 규격: viewBox PC 3840x1760, MO 2304x3500. 배경 이미지 꽉 차게 xMidYMid slice
            var viewBoxStr = '0 0 ' + vbW + ' ' + vbH;
            var svg = '<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="' + viewBoxStr + '" width="' + vbW + '" height="' + vbH + '">\n  ' + defsSection + '\n  <image x="0" y="0" width="' + vbW + '" height="' + vbH + '" href="' + base64 + '" preserveAspectRatio="xMidYMid slice"/>\n  ' + gradientNodes.join('\n  ') + '\n  ' + textNodes.join('\n  ') + '\n</svg>';
            console.log('피그마 SVG 생성 완료:', { variant: variant, viewBox: viewBoxStr, vbW: vbW, vbH: vbH, textNodesCount: textNodes.length });
            return svg;
        }
        
        function applyOverlayState(target) {
            var box = getOverlayBox(target);
            if (!box) return;
            var s = overlayState[target];
            box.style.left = s.x + 'px';
            box.style.top = s.y + 'px';
            var textSpan = getTextSpan(box);
            if (textSpan) textSpan.style.fontSize = (s.fontSize + 'px');
        }
        
        function updatePanelFromState(target) {
            var s = overlayState[target];
            var idMap = { 'mo-brand': 'editMoBrandSize', 'mo-keyword': 'editMoKeywordSize', 'pc-brand': 'editPcBrandSize', 'pc-keyword': 'editPcKeywordSize' };
            var el = document.getElementById(idMap[target]);
            if (el) el.value = s.fontSize;
        }
        
        // 텍스트 위치 고정: MO = 상단(중앙 정렬), PC = 좌측 여백 10% (피그마 SVG와 동일)
        function getTextStyleDefaults(brandKey) {
            var isDV = brandKey === 'DV';
            return {
                'mo-brand':  { centerHoriz: true, yRatio: 0.10, fs: 13, fontWeight: isDV ? '600' : '600' },
                'mo-keyword': { centerHoriz: true, yRatio: 0.18, fs: 26, fontWeight: isDV ? '700' : '700' },
                'pc-brand':  { leftAlign: true, leftMarginRatio: 0.10, yRatio: 0.36, fs: 15, fontWeight: isDV ? '600' : '600' },
                'pc-keyword': { leftAlign: true, leftMarginRatio: 0.10, yRatio: 0.46, fs: 32, fontWeight: isDV ? '700' : '700' }
            };
        }
        
        function initOverlayPositions() {
            var brandKey = selectedBrand || 'DV';
            var defaultsMap = getTextStyleDefaults(brandKey);
            var targets = ['mo-brand','mo-keyword','pc-brand','pc-keyword'];
            targets.forEach(function(target) {
                if (overlayInited[target]) return;
                var box = getOverlayBox(target);
                var container = getCaptureFor(target);
                if (!box || !container) return;
                var rect = container.getBoundingClientRect();
                var w = rect.width, h = rect.height;
                var d = defaultsMap[target] || { yRatio: 0.1, fs: 16, fontWeight: '600' };
                overlayState[target].fontSize = Math.max(8, Math.min(72, d.fs));
                overlayInited[target] = true;
                var textSpan = getTextSpan(box);
                if (textSpan) textSpan.style.fontWeight = d.fontWeight || '600';
                overlayState[target].x = 0;
                overlayState[target].y = h * d.yRatio;
                applyOverlayState(target);
                var boxW = box.offsetWidth || 80;
                var boxH = box.offsetHeight || 24;
                var margin = 8;
                var y = Math.max(0, Math.min(h - boxH - margin, h * d.yRatio));
                overlayState[target].y = y;
                var x;
                if (d.centerHoriz) {
                    x = (w - boxW) / 2;
                    x = Math.max(margin, Math.min(w - boxW - margin, x));
                } else if (d.leftAlign) {
                    x = w * (d.leftMarginRatio != null ? d.leftMarginRatio : 0.08);
                    x = Math.max(margin, Math.min(w - boxW - margin, x));
                } else if (d.rightAlign) {
                    var rMargin = w * (d.rightMarginRatio != null ? d.rightMarginRatio : 0.08);
                    x = Math.max(margin, w - boxW - rMargin);
                } else {
                    x = Math.max(margin, Math.min(w - boxW - margin, w * (d.xRatio != null ? d.xRatio : 0.05)));
                }
                overlayState[target].x = Math.max(0, Math.min(w - boxW - margin, x));
                applyOverlayState(target);
                updatePanelFromState(target);
            });
            var sizeIds = ['editMoBrandSize','editMoKeywordSize','editPcBrandSize','editPcKeywordSize'];
            var stateKeys = ['mo-brand','mo-keyword','pc-brand','pc-keyword'];
            stateKeys.forEach(function(k, i) {
                var el = document.getElementById(sizeIds[i]);
                if (el) el.value = overlayState[k].fontSize;
            });
        }
        
        function setupOverlayInteract() {
            if (typeof interact === 'undefined') return;
            interact('.overlay-text-box').draggable({
                ignoreFrom: '.resize-handle',
                listeners: {
                    start: function(e) {
                        e.target.classList.add('dragging');
                    },
                    move: function(e) {
                        var target = e.target.getAttribute('data-target');
                        var container = getCaptureFor(target);
                        if (!container) return;
                        var rect = container.getBoundingClientRect();
                        var state = overlayState[target];
                        state.x += e.dx;
                        state.y += e.dy;
                        state.x = Math.max(0, Math.min(rect.width - (e.target.offsetWidth || 20), state.x));
                        state.y = Math.max(0, Math.min(rect.height - (e.target.offsetHeight || 20), state.y));
                        e.target.style.left = state.x + 'px';
                        e.target.style.top = state.y + 'px';
                        updatePanelFromState(target);
                    },
                    end: function(e) {
                        e.target.classList.remove('dragging');
                    }
                }
            }).on('tap', function(e) {
                if (e.target.classList.contains('resize-handle')) e.stopPropagation();
            });
            
            document.querySelectorAll('.resize-handle').forEach(function(handle) {
                handle.addEventListener('mousedown', function(ev) {
                    ev.preventDefault(); ev.stopPropagation();
                    var box = handle.closest('.overlay-text-box');
                    var key = box.getAttribute('data-target');
                    var startY = ev.clientY; var startSize = overlayState[key].fontSize;
                    function move(e) {
                        var dy = e.clientY - startY;
                        var next = Math.max(8, Math.min(72, startSize + Math.round(dy * 0.5)));
                        overlayState[key].fontSize = next;
                        getTextSpan(box).style.fontSize = next + 'px';
                        updatePanelFromState(key);
                    }
                    function up() {
                        document.removeEventListener('mousemove', move);
                        document.removeEventListener('mouseup', up);
                    }
                    document.addEventListener('mousemove', move);
                    document.addEventListener('mouseup', up);
                });
            });
            
            var sizeInputs = { 'editMoBrandSize': 'mo-brand', 'editMoKeywordSize': 'mo-keyword', 'editPcBrandSize': 'pc-brand', 'editPcKeywordSize': 'pc-keyword' };
            Object.keys(sizeInputs).forEach(function(id) {
                var target = sizeInputs[id];
                document.getElementById(id)?.addEventListener('input', function() {
                    var v = Math.max(8, Math.min(72, parseInt(this.value, 10) || 14));
                    overlayState[target].fontSize = v;
                    applyOverlayState(target);
                });
            });
        }
        
        // 페이지 로드 시 트렌드 데이터 가져오기 및 이벤트 리스너 설정
        document.addEventListener('DOMContentLoaded', function() {
            fetchTrends();
            document.getElementById('trendsReloadBtn')?.addEventListener('click', function() {
                this.disabled = true;
                this.textContent = '불러오는 중...';
                fetchTrends().finally(function() {
                    var btn = document.getElementById('trendsReloadBtn');
                    if (btn) { btn.disabled = false; btn.textContent = '다시 불러오기'; }
                });
            });
            setupBrandSelection();
            setupTemplateSelection();
            setupGenerateButton();
            
            // 서버 상태 확인
            function checkServerStatus() {
                var statusEl = document.getElementById('serverStatus');
                var statusTextEl = document.getElementById('serverStatusText');
                if (!statusEl || !statusTextEl) return;
                
                fetch(API_BASE + '/health')
                    .then(function(r) {
                        if (r.ok) {
                            statusEl.classList.remove('hidden');
                            statusTextEl.textContent = '✅ 서버 연결됨 (Gemini·FAL·Replicate 사용 가능)';
                            statusTextEl.className = 'text-green-600';
                        } else {
                            throw new Error('서버 응답 오류');
                        }
                    })
                    .catch(function() {
                        statusEl.classList.remove('hidden');
                        statusTextEl.textContent = '⚠️ 서버 미연결 (FAL API로 자동 폴백)';
                        statusTextEl.className = 'text-orange-600';
                    });
            }
            
            // Replicate API 선택 시 서버 상태 확인
            document.querySelectorAll('input[name="imageApi"]').forEach(function(radio) {
                radio.addEventListener('change', function() {
                    if (this.value === 'replicate') {
                        checkServerStatus();
                    } else {
                        var statusEl = document.getElementById('serverStatus');
                        if (statusEl) statusEl.classList.add('hidden');
                    }
                });
            });
            (function setupReferenceImageAndAiMode() {
                // 이미지 리사이징 및 압축 함수 (토큰 소모 최적화)
                function compressImage(file, maxWidth, maxHeight, quality) {
                    return new Promise(function(resolve, reject) {
                        maxWidth = maxWidth || 1024; // 최대 너비 1024px
                        maxHeight = maxHeight || 1024; // 최대 높이 1024px
                        quality = quality || 0.85; // JPEG 품질 85%
                        
                        var reader = new FileReader();
                        reader.onload = function(e) {
                            var img = new Image();
                            img.onload = function() {
                                try {
                                    var canvas = document.createElement('canvas');
                                    var ctx = canvas.getContext('2d');
                                    
                                    // 비율 유지하며 리사이징
                                    var width = img.width;
                                    var height = img.height;
                                    if (width > maxWidth || height > maxHeight) {
                                        var ratio = Math.min(maxWidth / width, maxHeight / height);
                                        width = Math.round(width * ratio);
                                        height = Math.round(height * ratio);
                                    }
                                    
                                    canvas.width = width;
                                    canvas.height = height;
                                    
                                    // 이미지 그리기
                                    ctx.drawImage(img, 0, 0, width, height);
                                    
                                    // JPEG로 압축 (PNG보다 작음)
                                    var compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                                    
                                    // 파일 크기 확인
                                    var originalSize = file.size;
                                    var compressedSize = Math.round((compressedDataUrl.length - 'data:image/jpeg;base64,'.length) * 0.75); // base64는 약 33% 더 크므로
                                    
                                    console.log('📊 이미지 압축 결과:', {
                                        원본크기: (originalSize / 1024).toFixed(2) + ' KB',
                                        압축크기: (compressedSize / 1024).toFixed(2) + ' KB',
                                        압축률: ((1 - compressedSize / originalSize) * 100).toFixed(1) + '%',
                                        해상도: width + 'x' + height
                                    });
                                    
                                    resolve(compressedDataUrl);
                                } catch (err) {
                                    reject(err);
                                }
                            };
                            img.onerror = function() { reject(new Error('이미지 로드 실패')); };
                            img.src = e.target.result;
                        };
                        reader.onerror = function() { reject(new Error('파일 읽기 실패')); };
                        reader.readAsDataURL(file);
                    });
                }
                
                var zone = document.getElementById('referenceImageZone');
                var input = document.getElementById('referenceImageInput');
                var label = document.getElementById('referenceImageLabel');
                var hint = document.getElementById('aiModeHint');
                if (zone && input) {
                    zone.addEventListener('click', function() { input.click(); });
                    input.addEventListener('change', function() {
                        if (this.files && this.files.length > 0) {
                            var file = this.files[0];
                            
                            // 파일 크기 체크 (10MB 이상이면 경고)
                            if (file.size > 10 * 1024 * 1024) {
                                alert('이미지 파일이 너무 큽니다 (10MB 이상). 자동으로 압축됩니다.');
                            }
                            
                            // 파일 타입 체크
                            if (!file.type.match(/^image\/(jpeg|jpg|png|webp)/i)) {
                                alert('지원하는 이미지 형식: JPEG, PNG, WebP');
                                return;
                            }
                            
                            // 로딩 표시
                            if (label) { label.textContent = '이미지 압축 중...'; }
                            
                            // 이미지 압축 후 저장
                            compressImage(file, 1024, 1024, 0.85)
                                .then(function(compressedDataUrl) {
                                    referenceImageFromFile = compressedDataUrl;
                                    updateReferenceImage();
                                    referenceImageComposition = 'Reference image uploaded; use as main subject source.';
                                    if (label) { 
                                        var sizeKB = (file.size / 1024).toFixed(1);
                                        label.textContent = '업로드됨: ' + file.name + ' (' + sizeKB + ' KB → 압축됨)'; 
                                    }
                                    zone.classList.add('border-indigo-300', 'bg-indigo-50/30');
                                    console.log('✅ 이미지 압축 완료, 토큰 소모 최적화됨');
                                })
                                .catch(function(err) {
                                    console.error('❌ 이미지 압축 실패:', err);
                                    alert('이미지 처리 실패: ' + (err.message || '알 수 없는 오류'));
                                    referenceImageFromFile = null;
                                    updateReferenceImage();
                                    if (label) { label.textContent = '업로드 시 제품을 중심으로 배경을 연출합니다'; }
                                    zone.classList.remove('border-indigo-300', 'bg-indigo-50/30');
                                });
                        } else {
                            referenceImageFromFile = null;
                            updateReferenceImage();
                            referenceImageComposition = '';
                            if (label) { label.textContent = '업로드 시 제품을 중심으로 배경을 연출합니다'; }
                            zone.classList.remove('border-indigo-300', 'bg-indigo-50/30');
                        }
                    });
                }
                // 제품 이미지 URL 입력란 — FAL·Replicate 모두 image_url로 URL 지원
                var referenceImageUrlInputEl = document.getElementById('referenceImageUrlInput');
                function applyReferenceUrlFromInput(val) {
                    var v = (val || '').trim();
                    if (!v) {
                        referenceImageUrlFromInput = null;
                    } else {
                        if (!/^https?:\/\//i.test(v)) v = 'https://' + v;
                        if (/^https?:\/\/.+/i.test(v)) referenceImageUrlFromInput = v;
                        else referenceImageUrlFromInput = null;
                    }
                    updateReferenceImage();
                }
                if (referenceImageUrlInputEl) {
                    referenceImageUrlInputEl.addEventListener('input', function() { applyReferenceUrlFromInput(this.value); });
                    referenceImageUrlInputEl.addEventListener('blur', function() { applyReferenceUrlFromInput(this.value); });
                }
                document.querySelectorAll('input[name="aiGenerateMode"]').forEach(function(r) {
                    r.addEventListener('change', function() { selectedAiMode = this.value; });
                });
                
                // API 선택 이벤트 리스너
                document.querySelectorAll('input[name="imageApi"]').forEach(function(r) {
                    r.addEventListener('change', function() { 
                        selectedImageApi = this.value;
                        console.log('🔵 [API 변경]', selectedImageApi === 'replicate' ? 'Replicate API로 변경됨' : 'FAL API로 변경됨');
                    });
                });
            })();
            setupOverlayInteract();
            document.getElementById('downloadMoBtn')?.addEventListener('click', downloadMoImage);
            document.getElementById('downloadPcBtn')?.addEventListener('click', downloadPcImage);
            document.getElementById('downloadAllBtn')?.addEventListener('click', downloadAllImages);
            document.getElementById('copySvgMoBtn')?.addEventListener('click', async function() {
                var svg = await buildSvgForFigma('mo');
                if (svg && navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(svg).then(function() { alert('MO 시안 SVG가 클립보드에 복사되었습니다. 피그마에 붙여넣으세요.'); }).catch(function() { alert('클립보드 복사에 실패했습니다.'); });
                }
            });
            document.getElementById('copySvgPcBtn')?.addEventListener('click', async function() {
                var svg = await buildSvgForFigma('pc');
                if (svg && navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(svg).then(function() { alert('PC 시안 SVG가 클립보드에 복사되었습니다. 피그마에 붙여넣으세요.'); }).catch(function() { alert('클립보드 복사에 실패했습니다.'); });
                }
            });
            function syncResultTextFromInputs() {
                var editB = document.getElementById('editBrand');
                var editK = document.getElementById('editKeyword');
                var rMoB = document.getElementById('resultMoBrand'); var rMoK = document.getElementById('resultMoKeyword');
                var rPcB = document.getElementById('resultPcBrand'); var rPcK = document.getElementById('resultPcKeyword');
                var brandVal = editB ? editB.value : '';
                var keywordVal = editK ? editK.value : '';
                if (rMoB) rMoB.textContent = brandVal || rMoB.textContent;
                if (rMoK) rMoK.textContent = keywordVal || rMoK.textContent;
                if (rPcB) rPcB.textContent = brandVal || rPcB.textContent;
                if (rPcK) rPcK.textContent = keywordVal || rPcK.textContent;
            }
            ['editBrand','editKeyword'].forEach(function(id) {
                document.getElementById(id)?.addEventListener('input', syncResultTextFromInputs);
            });
            var developBtn = document.getElementById('developImageBtn');
            var regenBtn = document.getElementById('regenerateImageBtn');
            function setDevelopRegenDisabled(disabled) {
                if (developBtn) developBtn.disabled = disabled;
                if (regenBtn) regenBtn.disabled = disabled;
            }
            developBtn?.addEventListener('click', async function() {
                if (!selectedKeyword) { alert('먼저 키워드를 선택하고 시안을 생성해주세요.'); return; }
                if (!lastGeneratedImageUrl) { alert('먼저 AI 시안 생성하기로 이미지를 만든 뒤 디벨롭해주세요.'); return; }
                var feedback = (document.getElementById('resultFeedback')?.value || '').trim();
                if (!feedback) { alert('피드백 박스에 수정 지시를 입력해주세요. (예: 배경을 더 밝게)'); return; }
                var moImg = document.getElementById('resultMoImage');
                var pcImg = document.getElementById('resultPcImage');
                var loadingEl = document.getElementById('imageLoadingOverlay');
                var loadingMsg = document.getElementById('imageLoadingOverlayMessage');
                if (loadingMsg) loadingMsg.textContent = 'PC 시안 디벨롭 중...';
                setGenerateStatus('디벨롭 중...');
                setDevelopRegenDisabled(true);
                if (loadingEl) { loadingEl.classList.add('visible'); loadingEl.setAttribute('aria-hidden', 'false'); }
                try {
                    if (!lastGeneratedMoImageUrl || !lastGeneratedPcImageUrl) { alert('먼저 AI 시안 생성하기로 이미지를 만든 뒤 디벨롭해주세요.'); return; }
                    var pcUrl = await fetchFluxImageToImage(lastGeneratedPcImageUrl, feedback, 0.45);
                    if (loadingMsg) loadingMsg.textContent = '모바일 시안 디벨롭 중...';
                    var moUrl = await fetchFluxImageToImage(lastGeneratedMoImageUrl, feedback, 0.45);
                    if (pcUrl && moUrl) {
                        lastGeneratedPcImageUrl = pcUrl;
                        lastGeneratedMoImageUrl = moUrl;
                        lastGeneratedImageUrl = pcUrl;
                        moImg.crossOrigin = pcImg.crossOrigin = 'anonymous';
                        
                        // MO 이미지 강제 표시 로직 (디벨롭)
                        function forceShowMoDevelop() {
                            if (!moUrl) return;
                            moImg.src = '';
                            setTimeout(function() {
                                moImg.src = moUrl;
                                setTimeout(function() {
                                    if (moImg.complete || moImg.naturalWidth > 0) {
                                        moImg.classList.remove('hidden');
                                        var moPh = document.getElementById('resultMoPlaceholder');
                                        var moOverlay = document.getElementById('resultMoOverlay');
                                        if (moPh) moPh.classList.add('hidden');
                                        if (moOverlay) moOverlay.classList.remove('hidden');
                                        setTimeout(function() { initOverlayPositions(); }, 50);
                                    }
                                }, 100);
                            }, 10);
                        }
                        
                        moImg.onload = function() {
                            moImg.classList.remove('hidden');
                            var moPh = document.getElementById('resultMoPlaceholder');
                            var moOverlay = document.getElementById('resultMoOverlay');
                            if (moPh) moPh.classList.add('hidden');
                            if (moOverlay) moOverlay.classList.remove('hidden');
                            setTimeout(function() { initOverlayPositions(); }, 50);
                        };
                        moImg.onerror = function() {
                            // 에러 발생 시 조용히 처리 (사용자에게는 UI로 표시됨)
                        };
                        
                        pcImg.onload = function() {
                            pcImg.classList.remove('hidden');
                            var pcPh = document.getElementById('resultPcPlaceholder');
                            var pcOverlay = document.getElementById('resultPcOverlay');
                            if (pcPh) pcPh.classList.add('hidden');
                            if (pcOverlay) pcOverlay.classList.remove('hidden');
                            setTimeout(function() { initOverlayPositions(); }, 50);
                        };
                        
                        // 이미지 할당
                        pcImg.src = pcUrl;
                        forceShowMoDevelop();
                    } else { alert('이미지 디벨롭에 실패했습니다.'); }
                } finally {
                    setGenerateStatus('');
                    setDevelopRegenDisabled(false);
                    if (loadingEl) { loadingEl.classList.remove('visible'); loadingEl.setAttribute('aria-hidden', 'true'); }
                }
            });
            regenBtn?.addEventListener('click', async function() {
                if (!selectedKeyword) { alert('먼저 키워드를 선택하고 시안을 생성해주세요.'); return; }
                if (!lastImagePrompt) { alert('먼저 AI 시안 생성하기로 이미지를 만든 뒤 재생성해주세요.'); return; }
                var feedback = (document.getElementById('resultFeedback')?.value || '').trim();
                var moImg = document.getElementById('resultMoImage');
                var pcImg = document.getElementById('resultPcImage');
                var loadingEl = document.getElementById('imageLoadingOverlay');
                var loadingMsg = document.getElementById('imageLoadingOverlayMessage');
                if (loadingMsg) loadingMsg.textContent = 'PC 시안 재생성 중...';
                setGenerateStatus('새로 생성 중...');
                setDevelopRegenDisabled(true);
                if (loadingEl) { loadingEl.classList.add('visible'); loadingEl.setAttribute('aria-hidden', 'false'); }
                try {
                    var baseSeed = Math.floor(Math.random() * 1000000);
                    lastImageSeed = baseSeed;
                    var regenIntent = (feedback || lastDetailInstructions || '').trim();
                    if (loadingMsg) loadingMsg.textContent = 'MO·PC 시안 동시 재생성 중...';
                    var fusedMo = fusePrompt(selectedBrand, selectedKeyword, regenIntent, '', true, selectedAiMode || null);
                    var fusedPc = fusePrompt(selectedBrand, selectedKeyword, regenIntent, '', false, selectedAiMode || null);
                    var promMoRegen = fetchNanoBananaImage(selectedBrand, fusedMo, baseSeed, true, referenceImageUrl);
                    var promPcRegen = fetchNanoBananaImage(selectedBrand, fusedPc, baseSeed, false, referenceImageUrl);
                    var resultsRegen = await Promise.all([promMoRegen, promPcRegen]);
                    var moImageSrc = resultsRegen[0] || '';
                    var pcImageSrc = resultsRegen[1] || '';
                    if (!pcImageSrc && moImageSrc) pcImageSrc = moImageSrc;
                    lastGeneratedImageUrl = pcImageSrc;
                    lastGeneratedMoImageUrl = moImageSrc;
                    lastGeneratedPcImageUrl = pcImageSrc;
                    moImg.crossOrigin = pcImg.crossOrigin = 'anonymous';
                    var moPh = document.getElementById('resultMoPlaceholder');
                    var pcPh = document.getElementById('resultPcPlaceholder');
                    var moOverlay = document.getElementById('resultMoOverlay');
                    var pcOverlay = document.getElementById('resultPcOverlay');
                    function showMoRegen() {
                        moImg.classList.remove('hidden');
                        if (moPh) moPh.classList.add('hidden');
                        if (moOverlay) moOverlay.classList.remove('hidden');
                        setTimeout(function() { initOverlayPositions(); }, 50);
                    }
                    function showPcRegen() {
                        pcImg.classList.remove('hidden');
                        if (pcPh) pcPh.classList.add('hidden');
                        if (pcOverlay) pcOverlay.classList.remove('hidden');
                        setTimeout(function() { initOverlayPositions(); }, 50);
                    }
                    function hideMoRegen() {
                        moImg.classList.add('hidden');
                        if (moPh) moPh.classList.remove('hidden');
                        if (moOverlay) moOverlay.classList.add('hidden');
                    }
                    function hidePcRegen() {
                        pcImg.classList.add('hidden');
                        if (pcPh) pcPh.classList.remove('hidden');
                        if (pcOverlay) pcOverlay.classList.add('hidden');
                    }
                    
                    // 재생성 MO 이미지 생성 즉시 표시 (resultMoImage에 moImageSrc 할당 후 UI 즉시 전환)
                    function forceShowMoRegen() {
                        if (!moImageSrc) return;
                        var el = document.getElementById('resultMoImage');
                        if (!el || !el.parentNode) return;
                        lastGeneratedMoImageUrl = moImageSrc;
                        el.removeAttribute('crossorigin');
                        el.crossOrigin = '';
                        el.src = moImageSrc;
                        el.setAttribute('style', 'display: block !important; visibility: visible !important;');
                        el.style.setProperty('display', 'block', 'important');
                        el.style.setProperty('visibility', 'visible', 'important');
                        el.classList.remove('hidden');
                        if (moPh) moPh.classList.add('hidden');
                        if (moOverlay) moOverlay.classList.remove('hidden');
                        requestAnimationFrame(function() {
                            el.setAttribute('style', 'display: block !important; visibility: visible !important;');
                            el.classList.remove('hidden');
                        });
                        setTimeout(function() { initOverlayPositions(); }, 50);
                    }
                    moImg.onload = function() { 
                        moImg.classList.remove('hidden');
                        showMoRegen(); 
                    };
                    moImg.onerror = function() { 
                        hideMoRegen(); 
                    };
                    pcImg.onload = function() { 
                        showPcRegen(); 
                    };
                    pcImg.onerror = function() { 
                        hidePcRegen(); 
                    };
                    
                    // PC 이미지 할당
                    if (pcImageSrc && pcImageSrc !== pcImg.src) {
                        pcImg.src = '';
                        setTimeout(function() { pcImg.src = pcImageSrc; }, 10);
                    } else if (pcImageSrc) {
                        pcImg.src = pcImageSrc;
                    }
                    if (pcImg.complete && pcImageSrc) {
                        setTimeout(function() { if (pcImg.src === pcImageSrc) showPcRegen(); }, 100);
                    }
                    
                    // MO: moImageSrc 생성되자마자 resultMoImage.src 할당, display/hidden !important 강제
                    if (moImageSrc) {
                        if (moImg) {
                            moImg.src = moImageSrc;
                            moImg.style.setProperty('display', 'block', 'important');
                            moImg.style.setProperty('visibility', 'visible', 'important');
                            moImg.classList.remove('hidden');
                            if (moPh) moPh.classList.add('hidden');
                            if (moOverlay) moOverlay.classList.remove('hidden');
                        }
                        forceShowMoRegen();
                    } else {
                        console.error('재생성 MO 이미지 소스가 없습니다! moImageSrc:', moImageSrc);
                    }
                } finally {
                    setGenerateStatus('');
                    setDevelopRegenDisabled(false);
                    if (loadingEl) { loadingEl.classList.remove('visible'); loadingEl.setAttribute('aria-hidden', 'true'); }
                }
            });
        });
    </script>

</body>
</html>